import lombok.Data;

@Data
public class RetrievalDTO {

    private String detailRecordId;          // RETR-STB-DTL-REC-ID
    private String accountNumber;           // RETR-STB-ACCOUNT-NBR
    private String referenceKey;            // RETR-STB-REFERENCE-KEY
    private String systemId;                // RETR-STB-SYSTEM-ID
    private String sstKey;                  // RETR-STB-SST-KEY
    private String confirmationNumber;      // RETR-STB-CONF-NUM
    private String transactionReferenceId;  // RETR-STB-TRAN-REF-ID
    private String paymentType;             // RETR-STB-PAYMENT-TYPE
    private String xdays;                   // RETR-STB-XDAYS
    private String dueDate;                 // RETR-STB-DUE-DATE
    private String marketId;                // RETR-STB-MARKET-ID
    private String createTimestamp;         // RETR-STB-CREATE-TIMESTAMP
    private String subChannel;              // RETR-STB-SUB-CHANNEL
    private String statementBalance;        // RETR-STB-STMT-BAL
}


import lombok.extern.log4j.Log4j2;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;

@Component
@Log4j2
public class RetrievalDTOProcessor implements ItemProcessor<RetrievalDTO, ProcessedReportDTO> {

    private static final String DATE_FORMAT = "yyyyMMdd";  // Assuming dueDate is in this format

    @Override
    public ProcessedReportDTO process(RetrievalDTO item) throws Exception {
        
        // Step 1: Filter records by conditions
        if (!"COL".equals(item.getSubChannel()) || 
            Double.parseDouble(item.getStatementBalance()) <= 0.0) {
            return null;  // Skip this record if conditions not met
        }

        // Step 2: Calculate the hanging days
        LocalDate dueDate = LocalDate.parse(item.getDueDate(), DateTimeFormatter.ofPattern(DATE_FORMAT));
        LocalDate currentDate = LocalDate.now();

        DayOfWeek dayOfWeek = currentDate.getDayOfWeek();
        long hangingDays;

        if (dayOfWeek == DayOfWeek.SUNDAY) {
            // Sunday: hanging days = Current Date - (Due Date - 6 days)
            hangingDays = ChronoUnit.DAYS.between(dueDate.minusDays(6), currentDate);
        } else {
            // Monday to Saturday: hanging days = Current Date - (Due Date - 5 days)
            hangingDays = ChronoUnit.DAYS.between(dueDate.minusDays(5), currentDate);
        }

        // Step 3: Categorize the record
        String hangingCategory;
        if (hangingDays == 1) {
            hangingCategory = "GIVEN DAY + 1 DAY Section";
        } else if (hangingDays >= 7 && hangingDays < 25) {
            hangingCategory = "MORE THAN 7 DAYS Section";
        } else if (hangingDays >= 25) {
            hangingCategory = "MORE THAN 25 DAYS Section";
        } else {
            return null;  // Record does not fit into any category, skip
        }

        // Step 4: Prepare Report DTO
        ProcessedReportDTO reportDTO = new ProcessedReportDTO();
        
        // Use original DTO values for detailRecordId and paymentType
        reportDTO.setDetailRecordId(item.getDetailRecordId());
        reportDTO.setHangingDays(hangingDays);
        reportDTO.setCategory(hangingCategory);
        reportDTO.setPaymentType(getPaymentTypeDescription(item.getPaymentType()));

        return reportDTO;  // This will be passed to the writer
    }

    // This helper method maps the payment type to its description
    private String getPaymentTypeDescription(String paymentType) {
        switch (paymentType) {
            case "1": return "MIN";
            case "2": return "STMT_BAL";
            case "3": return "CONST_RECUR";
            default: return "UNKNOWN";
        }
    }
}



import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.batch.item.file.FlatFileItemReader;
import org.springframework.batch.item.file.mapping.DefaultLineMapper;
import org.springframework.batch.item.file.mapping.FieldSetMapper;
import org.springframework.batch.item.file.transform.FixedLengthTokenizer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.batch.item.file.transform.Range;
import org.springframework.batch.item.file.LineMapper;
import java.text.SimpleDateFormat;
import java.util.Map;

@Configuration
@RequiredArgsConstructor
@Log4j2
public class RetrievalDTOItemReader {

    @Value("${accountType.batch.file.input.fieldNames}")
    private String[] fieldNames;

    @Value("#{${accountType.batch.file.input.fieldRanges}}")
    private Map<Integer, Integer> fieldRanges;

    /**
     * Bean for FlatFileItemReader to read data from the file
     * @param fromLine Starting line in the file
     * @param toLine Ending line in the file
     * @param totalLines Total number of lines in the file
     * @return FlatFileItemReader<RetrievalDTO>
     * @throws Exception
     */
    @Bean
    public FlatFileItemReader<RetrievalDTO> getFlatFileItemReader(
            @Value("#{stepExecutionContext['fromLine']}") Integer fromLine,
            @Value("#{stepExecutionContext['toLine']}") Integer toLine,
            @Value("#{stepExecutionContext['numberOfRecords']}") Integer totalLines) throws Exception {

        FlatFileItemReader<RetrievalDTO> itemReader = new FlatFileItemReader<>();
        
        // Set the resource path for the file
        Resource resource = new FileSystemResource("path/to/your/input/file.txt");
        itemReader.setResource(resource);
        itemReader.setName("RetrievalDTOItemReader");
        
        // Set the LineMapper (maps each line to a DTO)
        itemReader.setLineMapper(lineMapper());

        // Logic for skipping lines based on fromLine and toLine
        if (fromLine == 1 && toLine.equals(totalLines)) {
            itemReader.setLinesToSkip(fromLine);
            itemReader.setMaxItemCount(toLine - fromLine);
        } else if (fromLine == 1) {
            itemReader.setLinesToSkip(fromLine);
            itemReader.setMaxItemCount(toLine - fromLine);
        } else if (toLine.equals(totalLines)) {
            itemReader.setLinesToSkip(fromLine - 1);
            itemReader.setMaxItemCount(toLine - fromLine);
        } else {
            itemReader.setLinesToSkip(fromLine - 1);
            itemReader.setMaxItemCount(toLine - fromLine + 1);
        }

        return itemReader;
    }

    /**
     * Maps the file data to the DTO (RetrievalDTO)
     * @return LineMapper<RetrievalDTO>
     * @throws Exception
     */
    private LineMapper<RetrievalDTO> lineMapper() throws Exception {
        DefaultLineMapper<RetrievalDTO> lineMapper = new DefaultLineMapper<>();

        // Tokenizer to define fixed-length columns
        FixedLengthTokenizer tokenizer = new FixedLengthTokenizer();
        tokenizer.setColumns(getRanges());
        tokenizer.setNames(fieldNames);

        lineMapper.setLineTokenizer(tokenizer);
        lineMapper.setFieldSetMapper(fieldSetMapper());

        return lineMapper;
    }

    /**
     * Sets the field mapping for RetrievalDTO
     * @return FieldSetMapper<RetrievalDTO>
     */
    private FieldSetMapper<RetrievalDTO> fieldSetMapper() {
        return field -> {
            RetrievalDTO dto = new RetrievalDTO();

            // Set values for the DTO from the file input
            dto.setDetailRecordId(field.readString("detailRecordId").trim());
            dto.setAccountNumber(field.readString("accountNumber").trim());
            dto.setReferenceKey(field.readString("referenceKey").trim());
            dto.setSystemId(field.readString("systemId").trim());
            dto.setSstKey(field.readString("sstKey").trim());
            dto.setConfirmationNumber(field.readString("confirmationNumber").trim());
            dto.setTransactionReferenceId(field.readString("transactionReferenceId").trim());
            dto.setPaymentType(field.readString("paymentType").trim());
            dto.setXdays(field.readString("xdays").trim());
            dto.setDueDate(field.readString("dueDate").trim());
            dto.setMarketId(field.readString("marketId").trim());
            dto.setCreateTimestamp(field.readString("createTimestamp").trim());
            dto.setSubChannel(field.readString("subChannel").trim());
            dto.setStatementBalance(field.readString("statementBalance").trim());

            return dto;
        };
    }

    /**
     * Converts the map of ranges into Range[] for FixedLengthTokenizer
     * @return Range[]
     * @throws Exception
     */
    private Range[] getRanges() throws Exception {
        Range[] ranges = new Range[fieldRanges.size()];
        int index = 0;
        for (Map.Entry<Integer, Integer> entry : fieldRanges.entrySet()) {
            ranges[index++] = new Range(entry.getKey(), entry.getValue());
        }
        return ranges;
    }
}


file.input.fieldNames=detailRecordId,accountNumber,referenceKey,systemId,sstKey,confirmationNumber,transactionReferenceId,paymentType,xdays,dueDate,marketId,createTimestamp,subChannel,statementBalance
file.input.fieldRanges=1-1,2-22,23-31,32-32,33-41,42-51,52-63,64-64,65-66,67-74,75-77,96-159,160-185,186-188
