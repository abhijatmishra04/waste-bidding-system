package com.bofa.sst.batch.core;

import com.bofa.sst.batch.util.CompCharaterUtil;
import lombok.extern.log4j.Log4j2;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemStream;
import org.springframework.batch.item.ItemStreamException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

@Component
@Log4j2
public class CustagCompFileReader implements ItemReader<CustomRecordDTO>, ItemStream {

    private BufferedInputStream bis = null;
    private int counter = 0;
    private int numberOfRecordsToRead = 0;

    @Value("${custag.input.file.path}")
    private String inputFilePath;

    private static final int RECORD_SIZE = 28;

    @Override
    public CustomRecordDTO read() throws Exception {
        if (bis == null) {
            throw new RuntimeException("BufferedInputStream is not initialized. Did you call open()?");
        }

        if (counter >= numberOfRecordsToRead) {
            log.info("All records have been read. Returning null.");
            return null;
        }

        byte[] readBytes = new byte[RECORD_SIZE];
        int bytesRead = bis.read(readBytes);

        if (bytesRead == -1) {
            log.warn("End of file reached unexpectedly. Returning null.");
            return null;
        } else if (bytesRead < RECORD_SIZE) {
            log.error("Incomplete record read. Expected {}, but got {} bytes.", RECORD_SIZE, bytesRead);
            throw new RuntimeException("Incomplete record read.");
        }

        counter++;
        log.debug("Read record number: {}", counter);
        return createRecord(readBytes);
    }

    @Override
    public void open(ExecutionContext executionContext) throws ItemStreamException {
        try {
            File inputFile = new File(inputFilePath);
            log.info("Attempting to open file at path: {}", inputFilePath);

            if (!inputFile.exists() || !inputFile.isFile()) {
                log.error("File does not exist or is not a valid file: {}", inputFilePath);
                throw new RuntimeException("File not found: " + inputFilePath);
            }

            bis = new BufferedInputStream(new FileInputStream(inputFile));
            long fileSize = inputFile.length();
            if (fileSize % RECORD_SIZE != 0) {
                log.warn("File size {} is not a multiple of RECORD_SIZE {}. Some records may be incomplete.", fileSize, RECORD_SIZE);
            }

            numberOfRecordsToRead = (int) (fileSize / RECORD_SIZE);
            log.info("Successfully opened file: {} with size: {} bytes. Total records: {}", inputFilePath, fileSize, numberOfRecordsToRead);
        } catch (IOException e) {
            log.error("Error occurred while opening the file: {}", inputFilePath, e);
            throw new ItemStreamException("Error opening file: " + inputFilePath, e);
        }
    }

    @Override
    public void update(ExecutionContext executionContext) throws ItemStreamException {
        // Can store `counter` if restartability is required
        executionContext.putInt("counter", counter);
    }

    @Override
    public void close() throws ItemStreamException {
        try {
            if (bis != null) {
                bis.close();
                log.info("Successfully closed the file.");
            }
        } catch (IOException e) {
            log.error("Error occurred while closing the file", e);
            throw new ItemStreamException("Error closing file", e);
        }
    }

    private CustomRecordDTO createRecord(byte[] reader) {
        CustomRecordDTO record = new CustomRecordDTO();

        try {
            String productCode = new String(parseField(reader, 0, 3), "UTF-8").trim();
            String entity = CompCharaterUtil.packedToString(parseField(reader, 3, 4)).trim();
            String accountNumber = new String(parseField(reader, 7, 21), "UTF-8").trim();

            record.setProductCode(productCode);
            record.setEntity(entity);
            record.setAccountNumber(accountNumber);

            log.info("Parsed record - ProductCode: {}, Entity: {}, AccountNumber: {}", productCode, entity, accountNumber);
        } catch (Exception e) {
            log.error("Error occurred while parsing the record", e);
            throw new RuntimeException("Error parsing record", e);
        }

        return record;
    }

    private byte[] parseField(byte[] reader, int offset, int length) {
        byte[] bytes = new byte[length];
        System.arraycopy(reader, offset, bytes, 0, length);
        log.debug("Parsed field from offset {} with length {}: {}", offset, length, new String(bytes).trim());
        return bytes;
    }
}
