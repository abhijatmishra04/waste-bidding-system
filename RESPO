@Override
public CustaggProcessedRecordsDTO process(CustaggRecordsDTO item) throws Exception {
    String entityFromFile = item.getEntity().trim();
    String accountNumber = item.getAccountNumber().trim();
    String productCode = item.getProductCode().trim();

    log.info("CustaggProcessor: Processing record - Entity: {}, AccountNumber: {}, ProductCode: {}",
             entityFromFile, accountNumber, productCode);

    // Ensure the entityMap is loaded
    if (entityMap.isEmpty()) {
        log.error("CustaggProcessor: The HashMap is empty! Ensure the EntityFileReader is correctly loading data.");
        throw new IllegalStateException("HashMap is empty. Check EntityFileReader.");
    }

    log.info("CustaggProcessor: HashMap contains {} entries.", entityMap.size());

    // Match entity from the HashMap
    String mappedEntity = entityMap.get(entityFromFile);
    if (mappedEntity != null) {
        CustaggProcessedRecordsDTO enrichedRecord = new CustaggProcessedRecordsDTO();
        enrichedRecord.setMappedEntity(mappedEntity);
        enrichedRecord.setNumEntity(entityFromFile);
        enrichedRecord.setAccountNumber(accountNumber);
        enrichedRecord.setProductCode(productCode);

        log.info("CustaggProcessor: Match found - NumEntity: {}, MappedEntity: {}", entityFromFile, mappedEntity);

        // Fetch schd_id from both sources
        List<String> scheduleIds = new ArrayList<>();

        String scheduleIdAccountBoa = fetchScheduleIdUsingAccountBoa(accountNumber, entityFromFile, productCode);
        if (scheduleIdAccountBoa != null) {
            scheduleIds.add(scheduleIdAccountBoa);
            log.info("CustaggProcessor: Fetched Schedule ID from Account_BOA: {}", scheduleIdAccountBoa);
        }

        String scheduleIdAccountM2M = fetchScheduleIdUsingAccountM2M(accountNumber, entityFromFile, productCode);
        if (scheduleIdAccountM2M != null) {
            scheduleIds.add(scheduleIdAccountM2M);
            log.info("CustaggProcessor: Fetched Schedule ID from Account_M2M: {}", scheduleIdAccountM2M);
        }

        enrichedRecord.setScheduleIds(scheduleIds); // Set the combined list of schd_ids
        return enrichedRecord;
    } else {
        log.info("CustaggProcessor: No match found for Entity: {} in the HashMap.", entityFromFile);
    }

    return null; // Skip records with no match
}

public class CustaggProcessedRecordsDTO {
    private String mappedEntity;
    private String numEntity;
    private String accountNumber;
    private String productCode;
    private List<String> scheduleIds; // Store multiple schd_ids

    // Getters and Setters for all fields, including scheduleIds
}



@Override
public void write(List<? extends CustaggProcessedRecordsDTO> items) throws Exception {
    log.info("CustaggWriter: Writing {} records to the database.", items.size());

    // Collect all Schedule IDs from the processed records
    List<String> allScheduleIds = new ArrayList<>();
    for (CustaggProcessedRecordsDTO record : items) {
        allScheduleIds.addAll(record.getScheduleIds());
    }

    // Perform batch update
    if (!allScheduleIds.isEmpty()) {
        updateScheduleM2M(allScheduleIds);
        log.info("CustaggWriter: Successfully updated {} ScheduleM2M records.", allScheduleIds.size());
    } else {
        log.warn("CustaggWriter: No Schedule IDs to update.");
    }
}

private void updateScheduleM2M(List<String> scheduleIds) {
    String updateQuery = CustaggSQLFactory.UPDATE_SCHEDULE_M2M;

    // Prepare parameters for batch update
    List<Object[]> batchParams = new ArrayList<>();
    Date currentDate = new Date(System.currentTimeMillis());
    Timestamp currentTimestamp = Timestamp.from(Instant.now());

    for (String scheduleId : scheduleIds) {
        batchParams.add(new Object[]{currentDate, currentTimestamp, scheduleId});
    }

    // Execute batch update
    jdbcTemplate.batchUpdate(updateQuery, batchParams);
    log.info("CustaggWriter: Executed batch update for {} Schedule IDs.", scheduleIds.size());
}

