@RunWith(MockitoJUnitRunner.class)
public class CustaggCompFileReaderTest {

    @InjectMocks
    private CustaggCompFileReader reader; // Class under test

    @Mock
    private M2MDynamicConfigPropertiesRepository mockRepository; // Mocked dependency

    @Mock
    private ExecutionContext mockExecutionContext; // Mocked ExecutionContext

    @Before
    public void setUp() {
        // Use ReflectionTestUtils to inject the private field 'inputFilePath'
        ReflectionTestUtils.setField(reader, "inputFilePath", "mocked/file/path");
    }

    @Test
    public void testOpen_success() throws Exception {
        // Mock ExecutionContext values
        Mockito.when(mockExecutionContext.getInt("fromLine")).thenReturn(1);
        Mockito.when(mockExecutionContext.getInt("toLine")).thenReturn(5);
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.DIRECTORY_PATH))
               .thenReturn("mocked/directory");
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA))
               .thenReturn("mockPrefix");

        // Call the method under test
        reader.open(mockExecutionContext);

        // Verify behavior and logs
        Assert.assertEquals(1, ReflectionTestUtils.getField(reader, "startLine"));
        Assert.assertEquals(5, ReflectionTestUtils.getField(reader, "endLine"));
    }

    @Test(expected = ItemStreamException.class)
    public void testOpen_fileNotFound() throws Exception {
        // Mock ExecutionContext values
        Mockito.when(mockExecutionContext.getInt("fromLine")).thenReturn(1);
        Mockito.when(mockExecutionContext.getInt("toLine")).thenReturn(5);
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.DIRECTORY_PATH))
               .thenReturn("mocked/directory");
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA))
               .thenReturn("nonexistentFile");

        // Call the method under test (expecting an exception)
        reader.open(mockExecutionContext);
    }

    @Test
    public void testRead_success() throws Exception {
        // Set private fields using ReflectionTestUtils
        ReflectionTestUtils.setField(reader, "bis", new ByteArrayInputStream(new byte[100]));
        ReflectionTestUtils.setField(reader, "numberOfRecordsToRead", 10);
        ReflectionTestUtils.setField(reader, "currentRecord", 0);

        // Call the method under test
        CustaggRecordsDTO result = reader.read();

        // Verify the result
        Assert.assertNotNull(result);
        Mockito.verifyZeroInteractions(mockRepository);
    }

    @Test
    public void testRead_endOfPartition() throws Exception {
        // Set private fields using ReflectionTestUtils
        ReflectionTestUtils.setField(reader, "numberOfRecordsToRead", 0);
        ReflectionTestUtils.setField(reader, "currentRecord", 1);

        // Call the method under test
        CustaggRecordsDTO result = reader.read();

        // Verify that null is returned for the end of partition
        Assert.assertNull(result);
    }

    @Test
    public void testCreateRecord_success() throws Exception {
        // Mock the input byte array
        byte[] mockBytes = new byte[100];
        ReflectionTestUtils.setField(reader, "bis", new ByteArrayInputStream(mockBytes));

        // Call the private method using reflection
        Method createRecordMethod = CustaggCompFileReader.class.getDeclaredMethod("createRecord", byte[].class);
        createRecordMethod.setAccessible(true);
        CustaggRecordsDTO result = (CustaggRecordsDTO) createRecordMethod.invoke(reader, mockBytes);

        // Verify the created DTO object
        Assert.assertNotNull(result);
    }

    @Test(expected = RuntimeException.class)
    public void testCreateRecord_failure() throws Exception {
        // Mock the input byte array
        byte[] mockBytes = new byte[100];

        // Simulate failure by throwing an exception
        Mockito.doThrow(new RuntimeException()).when(mockRepository).findById(Mockito.any());

        // Call the private method using reflection
        Method createRecordMethod = CustaggCompFileReader.class.getDeclaredMethod("createRecord", byte[].class);
        createRecordMethod.setAccessible(true);
        createRecordMethod.invoke(reader, mockBytes);
    }

    @Test
    public void testParseField() throws Exception {
        // Mock a byte array input
        byte[] mockBytes = new byte[100];

        // Call the private method using reflection
        Method parseFieldMethod = CustaggCompFileReader.class.getDeclaredMethod("parseField", byte[].class, int.class, int.class);
        parseFieldMethod.setAccessible(true);
        byte[] result = (byte[]) parseFieldMethod.invoke(reader, mockBytes, 0, 10);

        // Verify the result
        Assert.assertNotNull(result);
    }
}
