import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import org.junit.*;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.repeat.RepeatStatus;

@RunWith(MockitoJUnitRunner.class)
public class SdaResponseHeaderAndTrailerValidatorTaskletTest {

    @InjectMocks
    private SdaResponseHeaderAndTrailerValidatorTasklet tasklet;

    @Mock
    private StepContribution stepContribution;

    @Mock
    private ExecutionContext executionContext;

    @Mock
    private FileUtils fileUtils;

    @Mock
    private CompCharaterUtil compCharaterUtil;

    @Before
    public void setUp() throws Exception {
        when(stepContribution.getStepExecution()).thenReturn(mock(org.springframework.batch.core.StepExecution.class));
        when(stepContribution.getStepExecution().getJobExecution()).thenReturn(mock(org.springframework.batch.core.JobExecution.class));
        when(stepContribution.getStepExecution().getJobExecution().getExecutionContext()).thenReturn(executionContext);

        when(executionContext.getString(SdaResponseBatchConstants.RESPONSE_DIRECTORY_PATH)).thenReturn("/mock/response");
        when(executionContext.getString(SdaResponseBatchConstants.RESPONSE_INPUT_FILE_PREFIX)).thenReturn("responseFile");
        when(executionContext.getString(SdaResponseBatchConstants.REQUEST_DIRECTORY_PATH)).thenReturn("/mock/request");
        when(executionContext.getString(SdaResponseBatchConstants.REQUEST_INPUT_FILE_PREFIX)).thenReturn("requestFile");
    }

    @Test
    public void testExecute_Success() throws Exception {
        try (MockedStatic<Files> filesMock = mockStatic(Files.class)) {
            mockFileReading(filesMock, "HEADER123", "TRAILER123", "HEADER123", "TRAILER123");

            RepeatStatus status = tasklet.execute(stepContribution, null);

            verify(stepContribution, never()).setExitStatus(ExitStatus.FAILED);
            assertEquals(RepeatStatus.FINISHED, status);
        }
    }

    @Test
    public void testExecute_HeaderMismatch() throws Exception {
        try (MockedStatic<Files> filesMock = mockStatic(Files.class)) {
            mockFileReading(filesMock, "HEADER123", "TRAILER123", "HEADER999", "TRAILER123");

            RepeatStatus status = tasklet.execute(stepContribution, null);

            verify(stepContribution).setExitStatus(ExitStatus.FAILED);
            assertEquals(RepeatStatus.FINISHED, status);
        }
    }

    @Test
    public void testExecute_TrailerMismatch() throws Exception {
        try (MockedStatic<Files> filesMock = mockStatic(Files.class)) {
            mockFileReading(filesMock, "HEADER123", "TRAILER123", "HEADER123", "TRAILER999");

            RepeatStatus status = tasklet.execute(stepContribution, null);

            verify(stepContribution).setExitStatus(ExitStatus.FAILED);
            assertEquals(RepeatStatus.FINISHED, status);
        }
    }

    @Test
    public void testExecute_BothHeaderAndTrailerMismatch() throws Exception {
        try (MockedStatic<Files> filesMock = mockStatic(Files.class)) {
            mockFileReading(filesMock, "HEADER123", "TRAILER123", "HEADER999", "TRAILER999");

            RepeatStatus status = tasklet.execute(stepContribution, null);

            verify(stepContribution, times(2)).setExitStatus(ExitStatus.FAILED);
            assertEquals(RepeatStatus.FINISHED, status);
        }
    }

    @Test
    public void testExecute_NullHeadersAndTrailers() throws Exception {
        try (MockedStatic<Files> filesMock = mockStatic(Files.class)) {
            mockFileReading(filesMock, null, null, null, null);

            RepeatStatus status = tasklet.execute(stepContribution, null);

            verify(stepContribution).setExitStatus(ExitStatus.FAILED);
            assertEquals(RepeatStatus.FINISHED, status);
        }
    }

    @Test
    public void testExecute_FileReadFailure() throws Exception {
        when(FileUtils.findTodaysFiles(anyString(), anyString(), anyString())).thenThrow(new IOException("File not found"));

        RepeatStatus status = tasklet.execute(stepContribution, null);

        verify(stepContribution, never()).setExitStatus(ExitStatus.FAILED);
        assertEquals(RepeatStatus.FINISHED, status);
    }

    private void mockFileReading(MockedStatic<Files> filesMock, String resHeader, String resTrailer, String reqHeader, String reqTrailer) throws IOException {
        Path responsePath = Paths.get("/mock/response/responseFile.txt");
        Path requestPath = Paths.get("/mock/request/requestFile.txt");

        when(FileUtils.findTodaysFiles("/mock/response", "responseFile", SdaResponseBatchConstants.LOCK_FILE_EXTENSION))
                .thenReturn(responsePath.toString());
        when(FileUtils.findTodaysFiles("/mock/request", "requestFile", SdaResponseBatchConstants.LOCK_FILE_EXTENSION))
                .thenReturn(requestPath.toString());

        filesMock.when(() -> Files.readAllBytes(responsePath)).thenReturn(new byte[304]);
        filesMock.when(() -> Files.readAllBytes(requestPath)).thenReturn(new byte[304]);

        when(compCharaterUtil.ebcdicToAscii(any(byte[].class))).thenReturn(resHeader, resTrailer, reqHeader, reqTrailer);
    }
}
