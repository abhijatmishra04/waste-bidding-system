package com.bofa.sst.batch.core.impl;

import org.junit.*;
import org.mockito.Mockito;
import org.springframework.batch.core.*;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.item.ExecutionContext;

import java.io.*;
import java.nio.file.*;
import java.util.*;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class CustaggFileValidationTaskletTest {

    private CustaggFileValidationTasklet tasklet;
    private StepContribution stepContribution;
    private ChunkContext chunkContext;
    private ExecutionContext executionContext;
    private Path tempDirectory;
    private Path referDataFile;
    private Path referEntryFile;

    @Before
    public void setUp() throws Exception {
        // Initialize Tasklet
        tasklet = new CustaggFileValidationTasklet();

        // Mock StepContribution and ChunkContext
        stepContribution = mock(StepContribution.class);
        chunkContext = mock(ChunkContext.class);
        StepExecution stepExecution = mock(StepExecution.class);
        JobExecution jobExecution = mock(JobExecution.class);
        executionContext = new ExecutionContext();

        // Set up mocks
        when(chunkContext.getStepContext().getStepExecution()).thenReturn(stepExecution);
        when(stepExecution.getJobExecution()).thenReturn(jobExecution);
        when(jobExecution.getExecutionContext()).thenReturn(executionContext);

        // Create temporary files
        tempDirectory = Files.createTempDirectory("test-dir");
        referDataFile = tempDirectory.resolve("testReferData.dat");
        referEntryFile = tempDirectory.resolve("testReferEntry.dat");

        // Write mock data to files
        Files.write(referDataFile, "DATA01".getBytes());
        Files.write(referEntryFile, "ENTY1234\nENTY5678".getBytes());

        // Populate ExecutionContext
        executionContext.putString(CustaggBatchConstants.DIRECTORY_PATH, tempDirectory.toString());
        executionContext.putString(CustaggBatchConstants.FILE_PREFIX_REFERDATA, "testReferData");
        executionContext.putString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY, "testReferEntry");
    }

    @Test
    public void testExecute_Success() throws Exception {
        // Execute the tasklet
        RepeatStatus status = tasklet.execute(stepContribution, chunkContext);

        // Verify the tasklet completed successfully
        assertEquals(RepeatStatus.FINISHED, status);

        // Verify entityMap was created and added to ExecutionContext
        @SuppressWarnings("unchecked")
        Map<String, String> entityMap = (Map<String, String>) executionContext.get("entityMap");
        assertNotNull(entityMap);
        assertEquals(2, entityMap.size());
        assertEquals("ENTY", entityMap.get("1234"));
        assertEquals("ENTY", entityMap.get("5678"));
    }

    @Test(expected = FileNotFoundException.class)
    public void testExecute_FileNotFound() throws Exception {
        // Remove the referDataFile to simulate missing file
        Files.deleteIfExists(referDataFile);

        // Execute the tasklet
        tasklet.execute(stepContribution, chunkContext);
    }

    @Test(expected = Exception.class)
    public void testExecute_InvalidFileContent() throws Exception {
        // Write invalid content to referEntryFile
        Files.write(referEntryFile, "INVALID_CONTENT".getBytes(), StandardOpenOption.TRUNCATE_EXISTING);

        // Execute the tasklet
        tasklet.execute(stepContribution, chunkContext);
    }

    @After
    public void tearDown() throws Exception {
        // Cleanup temporary files
        Files.deleteIfExists(referDataFile);
        Files.deleteIfExists(referEntryFile);
        Files.deleteIfExists(tempDirectory);
    }
}
