package com.bofa.sst.batch.core;

import com.bofa.sst.batch.util.CompCharaterUtil;
import lombok.extern.log4j.Log4j2;
import org.springframework.batch.item.ItemReader;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

@Component
@Log4j2
public class CustagCompFileReader implements ItemReader<CustomRecordDTO> {

    private BufferedInputStream bis = null;
    private int counter = 0;
    private int numberOfRecordsToRead = 0;

    @Value("${custag.input.file.path}") // File path injected from properties
    private String inputFilePath;

    private static final int RECORD_SIZE = 28;

    @Override
    public CustomRecordDTO read() throws Exception {
        if (counter >= numberOfRecordsToRead) {
            log.info("All records have been read. Returning null.");
            return null;
        }

        byte[] readBytes = new byte[RECORD_SIZE];
        int bytesRead = bis.read(readBytes);

        if (bytesRead > 0) {
            counter++;
            log.debug("Read record number: {}", counter);
            return createRecord(readBytes);
        } else {
            log.warn("End of file reached or no data available to read.");
            return null;
        }
    }

    public void open() {
        try {
            File inputFile = new File(inputFilePath);
            log.info("Attempting to open file at path: {}", inputFilePath);

            if (!inputFile.exists() || !inputFile.isFile()) {
                log.error("File does not exist or is not a valid file: {}", inputFilePath);
                throw new RuntimeException("File not found: " + inputFilePath);
            }

            bis = new BufferedInputStream(new FileInputStream(inputFile));
            long fileSize = inputFile.length();
            numberOfRecordsToRead = (int) (fileSize / RECORD_SIZE);

            log.info("Successfully opened file: {} with size: {} bytes. Total records: {}", inputFilePath, fileSize, numberOfRecordsToRead);
        } catch (IOException e) {
            log.error("Error occurred while opening the file: {}", inputFilePath, e);
            throw new RuntimeException("Error opening file: " + inputFilePath, e);
        }
    }

    public void close() {
        try {
            if (bis != null) {
                bis.close();
                log.info("Successfully closed the file.");
            }
        } catch (IOException e) {
            log.error("Error occurred while closing the file", e);
        }
    }

    private CustomRecordDTO createRecord(byte[] reader) {
        CustomRecordDTO record = new CustomRecordDTO();

        try {
            String productCode = new String(parseField(reader, 0, 3), "UTF-8").trim();
            String entity = CompCharaterUtil.packedToString(parseField(reader, 3, 4)).trim();
            String accountNumber = new String(parseField(reader, 7, 21), "UTF-8").trim();

            record.setProductCode(productCode);
            record.setEntity(entity);
            record.setAccountNumber(accountNumber);

            log.info("Parsed record - ProductCode: {}, Entity: {}, AccountNumber: {}", productCode, entity, accountNumber);
        } catch (Exception e) {
            log.error("Error occurred while parsing the record", e);
            throw new RuntimeException("Error parsing record", e);
        }

        return record;
    }

    private byte[] parseField(byte[] reader, int offset, int length) {
        byte[] bytes = new byte[length];
        System.arraycopy(reader, offset, bytes, 0, length);
        log.debug("Parsed field from offset {} with length {}: {}", offset, length, new String(bytes).trim());
        return bytes;
    }
}
