package com.bofa.sst.batch.core.impl;

import com.bofa.sst.batch.constants.CustaggSQLFactory;
import org.junit.*;
import org.mockito.*;
import org.springframework.jdbc.core.JdbcTemplate;

import java.sql.Timestamp;
import java.time.Instant;
import java.util.*;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

public class CustaggWriterTest {

    private CustaggWriter writer;

    @Mock
    private JdbcTemplate jdbcTemplate;

    @Captor
    private ArgumentCaptor<List<Object[]>> batchParamsCaptor;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        writer = new CustaggWriter();
        ReflectionTestUtils.setField(writer, "jdbcTemplate", jdbcTemplate);
    }

    @Test
    public void testWrite_SuccessWithScheduleIds() throws Exception {
        // Prepare input records
        CustaggProcessedRecordsDTO record1 = new CustaggProcessedRecordsDTO();
        record1.setScheduleIds(Arrays.asList("SCHD001", "SCHD002"));

        CustaggProcessedRecordsDTO record2 = new CustaggProcessedRecordsDTO();
        record2.setScheduleIds(Arrays.asList("SCHD003"));

        List<CustaggProcessedRecordsDTO> records = Arrays.asList(record1, record2);

        // Call the method
        writer.write(records);

        // Verify batchUpdate is called once
        verify(jdbcTemplate, times(1)).batchUpdate(eq(CustaggSQLFactory.UPDATE_SCHEDULE_M2M), batchParamsCaptor.capture());

        // Validate batch parameters
        List<Object[]> capturedParams = batchParamsCaptor.getValue();
        assertEquals("Batch update should have 3 parameters", 3, capturedParams.size());
        
        assertEquals("SCHD001", capturedParams.get(0)[2]);
        assertEquals("SCHD002", capturedParams.get(1)[2]);
        assertEquals("SCHD003", capturedParams.get(2)[2]);

        assertNotNull("Timestamp should not be null", capturedParams.get(0)[1]);
        assertNotNull("Date should not be null", capturedParams.get(0)[0]);
    }

    @Test
    public void testWrite_NoScheduleIds() throws Exception {
        // Prepare input records with no schedule IDs
        CustaggProcessedRecordsDTO record1 = new CustaggProcessedRecordsDTO();
        record1.setScheduleIds(Collections.emptyList());

        CustaggProcessedRecordsDTO record2 = new CustaggProcessedRecordsDTO();
        record2.setScheduleIds(null);

        List<CustaggProcessedRecordsDTO> records = Arrays.asList(record1, record2);

        // Call the method
        writer.write(records);

        // Verify that batchUpdate is not called
        verify(jdbcTemplate, never()).batchUpdate(anyString(), anyList());
    }

    @Test
    public void testWrite_EmptyInputList() throws Exception {
        // Prepare empty input list
        List<CustaggProcessedRecordsDTO> records = new ArrayList<>();

        // Call the method
        writer.write(records);

        // Verify that batchUpdate is not called
        verify(jdbcTemplate, never()).batchUpdate(anyString(), anyList());
    }

    @Test
    public void testWrite_BatchUpdateFails() throws Exception {
        // Prepare input records
        CustaggProcessedRecordsDTO record1 = new CustaggProcessedRecordsDTO();
        record1.setScheduleIds(Arrays.asList("SCHD001"));

        List<CustaggProcessedRecordsDTO> records = Collections.singletonList(record1);

        // Simulate exception during batch update
        doThrow(new RuntimeException("Database error")).when(jdbcTemplate).batchUpdate(anyString(), anyList());

        try {
            writer.write(records);
            fail("Expected RuntimeException due to database error");
        } catch (RuntimeException e) {
            assertTrue(e.getMessage().contains("Database error"));
        }

        // Verify batchUpdate was called once
        verify(jdbcTemplate, times(1)).batchUpdate(anyString(), anyList());
    }

    @After
    public void tearDown() {
        writer = null;
        jdbcTemplate = null;
    }
}
