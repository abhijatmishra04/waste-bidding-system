@RunWith(MockitoJUnitRunner.class)
public class CustaggProcessorTest {

    @InjectMocks
    private CustaggProcessor processor;

    @Mock
    private JdbcTemplate mockJdbcTemplate;

    @Before
    public void setUp() {
        // Setup shared mocks if needed
    }

    @Test
    public void testFetchAndUpdateTransferExecutionIds_success() {
        List<String> scheduleIds = Arrays.asList("SCHED1", "SCHED2");
        List<String> transferExecutionIds = Arrays.asList("EXEC1", "EXEC2");

        Mockito.when(mockJdbcTemplate.queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_EXECUTION_M2M_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class)))
            .thenReturn("EXEC1", "EXEC2");

        List<String> result = processor.fetchAndUpdateTransferExecutionIds(scheduleIds);

        Assert.assertNotNull(result);
        Assert.assertEquals(2, result.size());
        Assert.assertEquals(transferExecutionIds, result);
    }

    @Test
    public void testFetchAndUpdateTransferExecutionIds_noTransferExecutionId() {
        List<String> scheduleIds = Arrays.asList("SCHED1", "SCHED2");

        Mockito.when(mockJdbcTemplate.queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_EXECUTION_M2M_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class)))
            .thenReturn(null);

        List<String> result = processor.fetchAndUpdateTransferExecutionIds(scheduleIds);

        Assert.assertNotNull(result);
        Assert.assertTrue(result.isEmpty());
    }

    @Test
    public void testFetchAndUpdateTransferExecutionIds_exception() {
        List<String> scheduleIds = Arrays.asList("SCHED1", "SCHED2");

        Mockito.when(mockJdbcTemplate.queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_EXECUTION_M2M_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class)))
            .thenThrow(new RuntimeException("Mocked Exception"));

        List<String> result = processor.fetchAndUpdateTransferExecutionIds(scheduleIds);

        Assert.assertNotNull(result);
        Assert.assertTrue(result.isEmpty());
    }

    @Test
    public void testUpdateTransferExecution_success() {
        List<String> transferExecutionIds = Arrays.asList("EXEC1", "EXEC2");

        Mockito.doNothing().when(mockJdbcTemplate).batchUpdate(
                Mockito.eq(CustaggSQLFactory.UPDATE_TRANSFER_EXECUTION_M2M),
                Mockito.anyList());

        processor.updateTransferExecution(transferExecutionIds);

        Mockito.verify(mockJdbcTemplate, Mockito.times(1)).batchUpdate(
                Mockito.eq(CustaggSQLFactory.UPDATE_TRANSFER_EXECUTION_M2M),
                Mockito.anyList());
    }

    @Test
    public void testUpdateTransferExecution_exception() {
        List<String> transferExecutionIds = Arrays.asList("EXEC1", "EXEC2");

        Mockito.doThrow(new RuntimeException("Mocked Exception"))
            .when(mockJdbcTemplate).batchUpdate(
                Mockito.eq(CustaggSQLFactory.UPDATE_TRANSFER_EXECUTION_M2M),
                Mockito.anyList());

        try {
            processor.updateTransferExecution(transferExecutionIds);
            Assert.fail("Expected RuntimeException to be thrown");
        } catch (RuntimeException e) {
            Assert.assertEquals("Mocked Exception", e.getMessage());
        }
    }

    @Test
    public void testFetchAndUpdateTransferInstructionIds_success() {
        List<String> scheduleIds = Arrays.asList("SCHED1", "SCHED2");

        Mockito.when(mockJdbcTemplate.queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_INSTRUCTION_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class)))
            .thenReturn("INSTR1", "INSTR2");

        processor.fetchAndUpdateTransferInstructionIds(scheduleIds);

        Mockito.verify(mockJdbcTemplate, Mockito.times(2)).queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_INSTRUCTION_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class));
    }

    @Test
    public void testFetchAndUpdateTransferInstructionIds_noInstructionId() {
        List<String> scheduleIds = Arrays.asList("SCHED1", "SCHED2");

        Mockito.when(mockJdbcTemplate.queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_INSTRUCTION_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class)))
            .thenReturn(null);

        processor.fetchAndUpdateTransferInstructionIds(scheduleIds);

        Mockito.verify(mockJdbcTemplate, Mockito.times(2)).queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_INSTRUCTION_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class));
    }

    @Test
    public void testFetchAndUpdateTransferInstructionIds_exception() {
        List<String> scheduleIds = Arrays.asList("SCHED1");

        Mockito.when(mockJdbcTemplate.queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_INSTRUCTION_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class)))
            .thenThrow(new RuntimeException("Mocked Exception"));

        processor.fetchAndUpdateTransferInstructionIds(scheduleIds);

        Mockito.verify(mockJdbcTemplate, Mockito.times(1)).queryForObject(
                Mockito.eq(CustaggSQLFactory.FETCH_TRANSFER_INSTRUCTION_ID),
                Mockito.eq(String.class),
                Mockito.any(Object[].class));
    }
}
