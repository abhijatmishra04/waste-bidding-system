package com.bofa.sst.batch.core;

import com.bofa.sst.batch.util.CompCharaterUtil;
import lombok.extern.log4j.Log4j2;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemStream;
import org.springframework.batch.item.ItemStreamException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

@Component
@Log4j2
public class CustagCompFileReader implements ItemReader<CustomRecordDTO>, ItemStream {

    private BufferedInputStream bis = null;
    private int counter = 0;
    private int startLine = 0;
    private int endLine = 0;
    private int currentRecord = 0;
    private int numberOfRecordsToRead = 0;

    @Value("${custag.input.file.path}")
    private String inputFilePath;

    private static final int RECORD_SIZE = 30; // Fixed record size

    @Override
    public void open(ExecutionContext executionContext) throws ItemStreamException {
        try {
            // Retrieve partition-specific start and end lines from ExecutionContext
            startLine = executionContext.getInt("fromLine");
            endLine = executionContext.getInt("toLine");

            log.info("CustagCompFileReader: Opening reader for partition: Start Line: {}, End Line: {}", startLine, endLine);

            File inputFile = new File(inputFilePath);
            if (!inputFile.exists()) {
                log.error("CustagCompFileReader: File does not exist at path: {}", inputFilePath);
                throw new RuntimeException("File not found: " + inputFilePath);
            }

            bis = new BufferedInputStream(new FileInputStream(inputFile));

            // Skip to the start line based on partition
            long skipBytes = (long) (startLine - 1) * RECORD_SIZE;
            if (bis.skip(skipBytes) != skipBytes) {
                log.error("CustagCompFileReader: Unable to skip to start line. Expected bytes to skip: {}", skipBytes);
                throw new RuntimeException("Error skipping to start line in file.");
            }

            numberOfRecordsToRead = endLine - startLine + 1;
            log.info("CustagCompFileReader: Successfully opened file for partition with {} records to read.", numberOfRecordsToRead);

        } catch (IOException e) {
            log.error("CustagCompFileReader: Error opening file.", e);
            throw new ItemStreamException("Error opening file", e);
        }
    }

    @Override
    public CustomRecordDTO read() throws Exception {
        if (currentRecord >= numberOfRecordsToRead) {
            log.info("CustagCompFileReader: All records for this partition have been read. Returning null.");
            return null;
        }

        byte[] readBytes = new byte[RECORD_SIZE];
        int bytesRead = bis.read(readBytes);

        if (bytesRead == -1) {
            log.info("CustagCompFileReader: End of file reached unexpectedly.");
            return null;
        } else if (bytesRead < RECORD_SIZE) {
            log.error("CustagCompFileReader: Incomplete record read. Expected: {}, but got: {}", RECORD_SIZE, bytesRead);
            throw new RuntimeException("Incomplete record read.");
        }

        currentRecord++;
        log.info("CustagCompFileReader: Read record number: {}", currentRecord);
        return createRecord(readBytes);
    }

    private CustomRecordDTO createRecord(byte[] reader) {
        try {
            String productCode = new String(parseField(reader, 0, 3), "UTF-8").trim();
            String entity = CompCharaterUtil.packedToString(parseField(reader, 3, 2)).trim();
            String accountNumber = new String(parseField(reader, 5, 23), "UTF-8").trim();

            CustomRecordDTO record = new CustomRecordDTO();
            record.setProductCode(productCode);
            record.setEntity(entity);
            record.setAccountNumber(accountNumber);

            log.info("CustagCompFileReader: Parsed record - ProductCode: {}, Entity: {}, AccountNumber: {}",
                     productCode, entity, accountNumber);
            return record;
        } catch (Exception e) {
            log.error("CustagCompFileReader: Error parsing record.", e);
            throw new RuntimeException("Error parsing record", e);
        }
    }

    private byte[] parseField(byte[] reader, int offset, int length) {
        byte[] field = new byte[length];
        System.arraycopy(reader, offset, field, 0, length);
        log.info("CustagCompFileReader: Parsed field from offset {} with length {}: {}", offset, length, new String(field).trim());
        return field;
    }

    @Override
    public void close() throws ItemStreamException {
        try {
            if (bis != null) {
                bis.close();
                log.info("CustagCompFileReader: Successfully closed the file.");
            }
        } catch (IOException e) {
            log.error("CustagCompFileReader: Error closing the file.", e);
            throw new ItemStreamException("Error closing file", e);
        }
    }

    @Override
    public void update(ExecutionContext executionContext) throws ItemStreamException {
        // Persist state if needed
        executionContext.putInt("counter", currentRecord);
    }
}
