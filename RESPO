package com.bofa.sst.batch.core.impl;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.when;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;

import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.repeat.RepeatStatus;

import com.bofa.sst.batch.core.constants.CustaggBatchConstants;  // adjust import if needed
import com.bofa.sst.batch.core.utils.FileUtils;                 // adjust import if needed

import lombok.extern.log4j.Log4j2;

@RunWith(MockitoJUnitRunner.class)
@Log4j2
public class CustaggFileValidationTaskletTest {

    @InjectMocks
    private CustaggFileValidationTasklet tasklet;

    @Mock
    private StepContribution stepContribution;

    @Mock
    private ChunkContext chunkContext;

    @Mock
    private ExecutionContext executionContext;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    /**
     * Test scenario where both referData and referEntry files are found,
     * locked successfully, and read without issues.
     */
    @Test
    public void testExecute_Success() throws Exception {
        // Mock job execution context
        when(chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext())
            .thenReturn(executionContext);

        // Setup the directory path, file prefixes, etc.
        when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn("/some/path");
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA)).thenReturn("prefixData");
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn("prefixEntry");

        // Mock FileUtils behavior
        when(FileUtils.findTodaysFiles("/some/path", "prefixData", CustaggBatchConstants.INPUT_FILE_EXTENSION))
            .thenReturn("/some/path/prefixData.dat");
        when(FileUtils.findTodaysFiles("/some/path", "prefixEntry", CustaggBatchConstants.INPUT_FILE_EXTENSION))
            .thenReturn("/some/path/prefixEntry.dat");
        when(FileUtils.findTodaysFiles("/some/path", "prefixEntry", CustaggBatchConstants.LOCK_FILE_EXTENSION))
            .thenReturn("/some/path/prefixEntry.lock");

        // Lock methods should not throw
        // (If they do, we'd either catch or let them propagate as in the original code)
        // You can also use doNothing() if you want to explicitly set the behavior:
        // doNothing().when(FileUtils).lockFile(anyString(), anyString(), anyString());

        // Mock reading the file
        // We can mock a simple data line for the .lock file reading.
        // Or use real I/O stubbing if you want. For brevity, let's just return
        // a BufferedReader from a known, trivial source.

        // Alternatively, you could create a partial mock approach or rely on an in-memory Reader.
        // This example uses a real FileReader approach to demonstrate structure, but typically you'd
        // avoid reading actual files in unit tests. Instead, you'd wrap or abstract file operations.
        // 
        // For demonstration, let's assume your "FileUtils.findTodaysFiles" returns a path that 
        // we can read from a test resource. Or we can short-circuit the actual read by manually 
        // injecting the lines via a wrapper, or a spy.

        // For a purely mocking approach, you could do something like:
        // BufferedReader brMock = mock(BufferedReader.class);
        // when(brMock.readLine()).thenReturn("ABCD1234", null); 
        // ...
        // But that would require altering the code to accept a Reader rather than constructing a 
        // new one in the tasklet. Another approach is to not test file reading in detail here 
        // but rely on integration tests for that portion.

        // For now, let's skip the actual I/O mocking complexity. If we do nothing, the code would
        // attempt to read the .lock file. You can handle that by expecting an exception if that file
        // doesn't exist or by adjusting your local environment to have such a file.
        // 
        // Let's just demonstrate structure:

        RepeatStatus status = tasklet.execute(stepContribution, chunkContext);

        // Verify the tasklet's completion
        Assert.assertEquals(RepeatStatus.FINISHED, status);
    }

    /**
     * Test scenario where referData file cannot be found, 
     * leading to a FileNotFoundException.
     */
    @Test(expected = FileNotFoundException.class)
    public void testExecute_FileNotFound() throws Exception {
        // Mock job execution context
        when(chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext())
            .thenReturn(executionContext);

        // Setup the directory path, file prefixes, etc.
        when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn("/some/path");
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA)).thenReturn("prefixData");
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn("prefixEntry");

        // Force findTodaysFiles to return null, simulating a missing file
        when(FileUtils.findTodaysFiles("/some/path", "prefixData", CustaggBatchConstants.INPUT_FILE_EXTENSION))
            .thenReturn(null);

        // Execute
        tasklet.execute(stepContribution, chunkContext);

        // Expect a FileNotFoundException to be thrown
    }

    /**
     * Test scenario where an IOException occurs during reading the file.
     * This helps ensure the tasklet properly handles or propagates IO exceptions.
     */
    @Test(expected = Exception.class)
    public void testExecute_IOExceptionDuringRead() throws Exception {
        // Mock job execution context
        when(chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext())
            .thenReturn(executionContext);

        // Setup the directory path, file prefixes, etc.
        when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn("/some/path");
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA)).thenReturn("prefixData");
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn("prefixEntry");

        // Mock successful find
        when(FileUtils.findTodaysFiles("/some/path", "prefixData", CustaggBatchConstants.INPUT_FILE_EXTENSION))
            .thenReturn("/some/path/prefixData.dat");
        when(FileUtils.findTodaysFiles("/some/path", "prefixEntry", CustaggBatchConstants.INPUT_FILE_EXTENSION))
            .thenReturn("/some/path/prefixEntry.dat");

        // Mock the locked file as well
        when(FileUtils.findTodaysFiles("/some/path", "prefixEntry", CustaggBatchConstants.LOCK_FILE_EXTENSION))
            .thenReturn("/some/path/prefixEntry.lock");

        // Now simulate an IOException while reading
        // One way is to mock the FileReader or BufferedReader creation if you abstract them.
        // Another simpler approach here is to cause a read-time exception by mocking FileUtils
        // or forcing the path to be unreadable. For demonstration:

        // If you have logic in your code that calls new FileReader(), you can't easily mock it 
        // directly unless you further abstract it. 
        // Let's do a simpler approach: Let's say that locking fails, or the code fails at the line:
        doThrow(new IOException("Mocked IO error")).when(FileUtils).lockFile("/some/path", "prefixEntry", CustaggBatchConstants.INPUT_FILE_EXTENSION);

        // Execute
        tasklet.execute(stepContribution, chunkContext);

        // We expect an Exception because the code catches only certain exceptions, but you can 
        // adapt if needed.
    }

    /**
     * Test scenario verifying the "entityMap" is properly put into the execution context.
     * This requires the file read to succeed and a valid line to be processed.
     * 
     * For a pure unit test, you'd typically mock reading lines. But if you rely on real I/O,
     * place a small test file under src/test/resources to read from. We'll assume
     * the read is successful and the lines are something like "ABCD1234".
     */
    @Test
    public void testExecute_EntityMapPopulation() throws Exception {
        // Mock job execution context
        when(chunkContext.getStepContext().getStepExecution().getJobExecution().getExecutionContext())
            .thenReturn(executionContext);

        // Setup the directory path, file prefixes, etc.
        when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn("/some/path");
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA)).thenReturn("prefixData");
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn("prefixEntry");

        // Mock successful find
        when(FileUtils.findTodaysFiles("/some/path", "prefixData", CustaggBatchConstants.INPUT_FILE_EXTENSION))
            .thenReturn("/some/path/prefixData.dat");
        when(FileUtils.findTodaysFiles("/some/path", "prefixEntry", CustaggBatchConstants.INPUT_FILE_EXTENSION))
            .thenReturn("/some/path/prefixEntry.dat");
        when(FileUtils.findTodaysFiles("/some/path", "prefixEntry", CustaggBatchConstants.LOCK_FILE_EXTENSION))
            .thenReturn("/some/path/prefixEntry.lock");

        // (Optional) Mock the lock as successful
        // doNothing().when(FileUtils).lockFile(anyString(), anyString(), anyString());

        // Execute
        RepeatStatus status = tasklet.execute(stepContribution, chunkContext);
        Assert.assertEquals(RepeatStatus.FINISHED, status);

        // Now verify the entityMap was put into the ExecutionContext
        // By default, if the test environment cannot read the file, 
        // entityMap might be empty. But let's assume there's at least 1 line 
        // that was processed. We'll check that the map is not null in the context.
        // 
        // If you want to verify the exact entries, you'd need a controlled input file
        // or a way to mock the reading to supply lines. For demonstration, let's just
        // verify it was set:

        HashMap<String, String> entityMap =
            (HashMap<String, String>) executionContext.get("entityMap");

        Assert.assertNotNull("Expected entityMap to be populated in the execution context", entityMap);
        // You could also check the size or keys if your test environment is predictable
        // Assert.assertTrue(entityMap.size() > 0);
    }
}
