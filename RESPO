package com.bofa.sst.batch.core.impl;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.*;
import java.util.HashMap;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.stubbing.Answer;
import org.powermock.api.mockito.PowerMockito;
import org.powermock.core.classloader.annotations.PrepareForTest;
import org.powermock.modules.junit4.PowerMockRunner;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.core.scope.context.StepExecutionContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.repeat.RepeatStatus;

@RunWith(PowerMockRunner.class)
@PrepareForTest({ FileUtils.class, CustaggBatchConstants.class })
public class CustaggFileValidationTaskletTest {

    @InjectMocks
    private CustaggFileValidationTasklet tasklet;

    @Mock
    private StepContribution stepContribution;

    @Mock
    private ChunkContext chunkContext;

    @Mock
    private StepContext stepContext;

    @Mock
    private ExecutionContext executionContext;

    private static final String DIRECTORY_PATH = "/test/path";
    private static final String FILE_PREFIX_REFERDATA = "testData";
    private static final String FILE_PREFIX_REFERENTRY = "testEntry";
    private static final String TEST_FILE_PATH = "/test/path/testEntry.dat";

    @Before
    public void setUp() throws Exception {
        MockitoAnnotations.initMocks(this);

        when(chunkContext.getStepContext()).thenReturn(stepContext);
        when(stepContext.getStepExecution()).thenReturn(stepContribution.getStepExecution());
        when(stepContribution.getStepExecution().getJobExecution().getExecutionContext()).thenReturn(executionContext);

        when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn(DIRECTORY_PATH);
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA)).thenReturn(FILE_PREFIX_REFERDATA);
        when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn(FILE_PREFIX_REFERENTRY);

        // Mocking FileUtils Static Methods
        PowerMockito.mockStatic(FileUtils.class);
    }

    @Test
    public void testExecuteSuccess() throws Exception {
        try (MockedStatic<FileUtils> toMock = mockStatic(FileUtils.class)) {

            String filePathForReferData = "C:\\test\\testData.dat";
            String filePathForReferEntry = "C:\\test\\testEntry.dat";
            String lockedFilePath = "C:\\test\\testEntry.lock";

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERDATA, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn(filePathForReferData);

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn(filePathForReferEntry);

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.LOCK_FILE_EXTENSION))
                    .thenReturn(lockedFilePath);

            PowerMockito.doNothing().when(FileUtils.class);
            FileUtils.lockFile(anyString(), anyString(), anyString());

            RepeatStatus status = tasklet.execute(stepContribution, chunkContext);

            assertEquals(RepeatStatus.FINISHED, status);
            verify(stepContribution).setExitStatus(ExitStatus.COMPLETED);
            verify(executionContext).put(eq("entityMap"), any(HashMap.class));

            toMock.verify(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERDATA, CustaggBatchConstants.INPUT_FILE_EXTENSION));
            toMock.verify(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.INPUT_FILE_EXTENSION));
            toMock.verify(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.LOCK_FILE_EXTENSION));
        }
    }

    @Test(expected = FileNotFoundException.class)
    public void testExecuteFileNotFound() throws Exception {
        try (MockedStatic<FileUtils> toMock = mockStatic(FileUtils.class)) {

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERDATA, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn(null);

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn(null);

            tasklet.execute(stepContribution, chunkContext);
        }
    }

    @Test(expected = Exception.class)
    public void testExecuteFileReadError() throws Exception {
        try (MockedStatic<FileUtils> toMock = mockStatic(FileUtils.class)) {

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.LOCK_FILE_EXTENSION))
                    .thenReturn("/invalid/path");

            tasklet.execute(stepContribution, chunkContext);
        }
    }
}
