package com.bofa.sst.batch.core.impl;

import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.*;

import java.io.*;
import java.util.HashMap;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.repeat.RepeatStatus;

@RunWith(MockitoJUnitRunner.class)
public class CustaggFileValidationTaskletTest {

    @InjectMocks
    private CustaggFileValidationTasklet tasklet;

    @Mock
    private StepContribution stepContribution;

    @Mock
    private ChunkContext chunkContext;

    @Mock
    private StepContext stepContext;

    @Mock
    private StepExecution stepExecution;

    @Mock
    private ExecutionContext executionContext;

    private static final String DIRECTORY_PATH = "C:\\test\\";
    private static final String FILE_PREFIX_REFERDATA = "testData";
    private static final String FILE_PREFIX_REFERENTRY = "testEntry";
    private static final String REFERDATA_FILE_PATH = "C:\\test\\testData_20250212.dat";
    private static final String REFERENTRY_FILE_PATH = "C:\\test\\testEntry_20250212.dat";
    private static final String LOCKED_FILE_PATH = "C:\\test\\testEntry_20250212.lock";

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);

        // Debugging: Ensure mocks are initialized
        System.out.println("stepContribution: " + stepContribution);
        System.out.println("chunkContext: " + chunkContext);
        System.out.println("stepContext: " + stepContext);
        System.out.println("stepExecution: " + stepExecution);
        System.out.println("executionContext: " + executionContext);

        // Prevent NullPointerException by ensuring StepExecution and ExecutionContext are properly returned
        when(chunkContext.getStepContext()).thenReturn(stepContext);
        when(stepContext.getStepExecution()).thenReturn(stepExecution);
        when(stepContribution.getStepExecution()).thenReturn(stepExecution);
        
        ExecutionContext executionContextMock = mock(ExecutionContext.class);
        when(stepExecution.getJobExecution().getExecutionContext()).thenReturn(executionContextMock);

        // Mock execution context values to avoid NPE
        when(executionContextMock.getString(anyString())).thenReturn("mocked_value");
    }

    @Test
    public void testExecuteSuccess() throws Exception {
        try (MockedStatic<FileUtils> toMock = Mockito.mockStatic(FileUtils.class)) {
            
            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERDATA, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                 .thenReturn(REFERDATA_FILE_PATH);

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                 .thenReturn(REFERENTRY_FILE_PATH);

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.LOCK_FILE_EXTENSION))
                 .thenReturn(LOCKED_FILE_PATH);

            toMock.when(() -> FileUtils.lockFile(DIRECTORY_PATH, FILE_PREFIX_REFERDATA, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                 .thenAnswer(invocation -> null);

            toMock.when(() -> FileUtils.lockFile(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                 .thenAnswer(invocation -> null);

            RepeatStatus status = tasklet.execute(stepContribution, chunkContext);

            assertNotNull(status);
            verify(stepContribution).setExitStatus(ExitStatus.COMPLETED);
            verify(executionContext).put(eq("entityMap"), any(HashMap.class));

            toMock.verify(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERDATA, CustaggBatchConstants.INPUT_FILE_EXTENSION));
            toMock.verify(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.INPUT_FILE_EXTENSION));
            toMock.verify(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.LOCK_FILE_EXTENSION));
        }
    }

    @Test(expected = FileNotFoundException.class)
    public void testExecuteFileNotFound() throws Exception {
        try (MockedStatic<FileUtils> toMock = Mockito.mockStatic(FileUtils.class)) {

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERDATA, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                 .thenReturn(null);

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.INPUT_FILE_EXTENSION))
                 .thenReturn(null);

            tasklet.execute(stepContribution, chunkContext);
        }
    }

    @Test(expected = Exception.class)
    public void testExecuteFileReadError() throws Exception {
        try (MockedStatic<FileUtils> toMock = Mockito.mockStatic(FileUtils.class)) {

            toMock.when(() -> FileUtils.findTodaysFiles(DIRECTORY_PATH, FILE_PREFIX_REFERENTRY, CustaggBatchConstants.LOCK_FILE_EXTENSION))
                 .thenReturn("/invalid/path");

            tasklet.execute(stepContribution, chunkContext);
        }
    }
}
