private void aggregateFilesForLetterType(String sourceDir, String letterType, StringBuilder finalAggregatedContent) throws IOException {
    Path sourcePath = Paths.get(sourceDir).toAbsolutePath();
    log.trace("Resolved sourcePath: {}", sourcePath.toString());

    Pattern pattern = Pattern.compile(CollectionLettersBatchConstants.PATTERN_1 + letterType + CollectionLettersBatchConstants.PATTERN_2);

    try (Stream<Path> filesStream = Files.list(sourcePath)) {
        List<Path> matchingFiles = filesStream
                .filter(path -> pattern.matcher(path.getFileName().toString()).matches())
                .sorted()
                .collect(Collectors.toList());

        if (matchingFiles.isEmpty()) {
            log.warn("No files found for letter type: {}", letterType);
            return;
        }

        // Create a StringBuilder for the current letter type
        StringBuilder aggregatedContent = new StringBuilder();
        String header = String.format(CollectionLettersBatchConstants.HEADER_FORMAT,
                LocalDateTime.now().format(CollectionLettersBatchConstants.HEADER_DATE_FORMAT));
        aggregatedContent.append(header).append(System.lineSeparator());

        int totalRecordsCount = 0;
        for (Path filePath : matchingFiles) {
            try {
                List<String> lines = Files.readAllLines(filePath);
                if (lines.size() > 2) {
                    for (int i = 1; i < lines.size(); i++) { // Skip header line
                        aggregatedContent.append(lines.get(i)).append(System.lineSeparator());
                        totalRecordsCount++;
                    }
                }
            } catch (IOException e) {
                log.error("Error reading file: {}", filePath.getFileName(), e);
            }
        }

        // Add a trailer to the aggregated content
        String trailer = String.format(CollectionLettersBatchConstants.TRAILER_FORMAT1, totalRecordsCount);
        aggregatedContent.append(trailer).append(System.lineSeparator());

        // Write the aggregated letter to its file
        Path outputPath = sourcePath.resolve(letterType + "_Letter.txt");
        try {
            Files.write(outputPath, aggregatedContent.toString().getBytes());
            log.trace("Aggregated content written to file: {}", outputPath.getFileName());
        } catch (IOException e) {
            log.error("Error writing to output file: {}", outputPath.getFileName(), e);
        }

        // Append the aggregated content of this letter type to the final aggregated letter
        finalAggregatedContent.append(aggregatedContent).append(System.lineSeparator());

        // Delete the temporary files after processing
        for (Path filePath : matchingFiles) {
            if (!filePath.equals(outputPath)) {
                try {
                    Files.delete(filePath);
                    log.trace("Deleted temporary file: {}", filePath.getFileName());
                } catch (NoSuchFileException e) {
                    log.error("File not found: {}", filePath.getFileName(), e);
                } catch (IOException e) {
                    log.error("Error deleting file: {}", filePath.getFileName(), e);
                }
            }
        }
    }
}
