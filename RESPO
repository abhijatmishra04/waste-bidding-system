@RunWith(MockitoJUnitRunner.class)
public class CustaggCompFileReaderTest {

    @InjectMocks
    private CustaggCompFileReader reader; // Class under test

    @Mock
    private ExecutionContext mockExecutionContext;

    @Mock
    private M2MDynamicConfigPropertiesRepository mockRepository;

    @Mock
    private FileUtils fileUtils; // If FileUtils is static, mock its behavior using Mockito.mockStatic.

    @Before
    public void setUp() {
        // Use ReflectionTestUtils to set private fields
        ReflectionTestUtils.setField(reader, "dynamicConfigPropertiesRepository", mockRepository);
    }

    @Test
    public void testOpen_success() throws Exception {
        // Mock ExecutionContext values
        Mockito.when(mockExecutionContext.getInt("fromLine")).thenReturn(1);
        Mockito.when(mockExecutionContext.getInt("toLine")).thenReturn(5);
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.DIRECTORY_PATH))
               .thenReturn("mocked/directory");
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA))
               .thenReturn("mockPrefix");

        // Mock FileUtils to return a valid file path
        Mockito.mockStatic(FileUtils.class);
        Mockito.when(FileUtils.findTodaysFiles("mocked/directory", "mockPrefix", CustaggBatchConstants.LOCK_FILE_EXTENSION))
               .thenReturn("mocked/file/path");

        // Call the method under test
        reader.open(mockExecutionContext);

        // Verify the state of the reader
        Assert.assertEquals(1, ReflectionTestUtils.getField(reader, "startLine"));
        Assert.assertEquals(5, ReflectionTestUtils.getField(reader, "endLine"));
    }

    @Test(expected = ItemStreamException.class)
    public void testOpen_fileNotFound() throws Exception {
        // Mock ExecutionContext values
        Mockito.when(mockExecutionContext.getInt("fromLine")).thenReturn(1);
        Mockito.when(mockExecutionContext.getInt("toLine")).thenReturn(5);
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.DIRECTORY_PATH))
               .thenReturn("mocked/directory");
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA))
               .thenReturn("mockPrefix");

        // Mock FileUtils to return a non-existent file path
        Mockito.mockStatic(FileUtils.class);
        Mockito.when(FileUtils.findTodaysFiles("mocked/directory", "mockPrefix", CustaggBatchConstants.LOCK_FILE_EXTENSION))
               .thenReturn("nonexistent/file/path");

        // Call the method under test (expecting an exception)
        reader.open(mockExecutionContext);
    }

    @Test(expected = RuntimeException.class)
    public void testOpen_skipBytesError() throws Exception {
        // Mock ExecutionContext values
        Mockito.when(mockExecutionContext.getInt("fromLine")).thenReturn(2);
        Mockito.when(mockExecutionContext.getInt("toLine")).thenReturn(5);
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.DIRECTORY_PATH))
               .thenReturn("mocked/directory");
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA))
               .thenReturn("mockPrefix");

        // Mock FileUtils to return a valid file path
        Mockito.mockStatic(FileUtils.class);
        Mockito.when(FileUtils.findTodaysFiles("mocked/directory", "mockPrefix", CustaggBatchConstants.LOCK_FILE_EXTENSION))
               .thenReturn("mocked/file/path");

        // Mock BufferedInputStream to simulate a skipping error
        BufferedInputStream mockInputStream = Mockito.mock(BufferedInputStream.class);
        Mockito.when(mockInputStream.skip(Mockito.anyLong())).thenReturn(0L); // Simulate skip failure
        ReflectionTestUtils.setField(reader, "bis", mockInputStream);

        // Call the method under test (expecting an exception)
        reader.open(mockExecutionContext);
    }

    @Test
    public void testOpen_incompleteRecords() throws Exception {
        // Mock ExecutionContext values
        Mockito.when(mockExecutionContext.getInt("fromLine")).thenReturn(1);
        Mockito.when(mockExecutionContext.getInt("toLine")).thenReturn(5);
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.DIRECTORY_PATH))
               .thenReturn("mocked/directory");
        Mockito.when(mockExecutionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA))
               .thenReturn("mockPrefix");

        // Mock FileUtils to return a valid file path
        Mockito.mockStatic(FileUtils.class);
        Mockito.when(FileUtils.findTodaysFiles("mocked/directory", "mockPrefix", CustaggBatchConstants.LOCK_FILE_EXTENSION))
               .thenReturn("mocked/file/path");

        // Mock BufferedInputStream
        byte[] mockData = new byte[50];
        BufferedInputStream mockInputStream = new BufferedInputStream(new ByteArrayInputStream(mockData));
        ReflectionTestUtils.setField(reader, "bis", mockInputStream);

        // Call the method under test
        reader.open(mockExecutionContext);

        // Verify the state of the reader
        Assert.assertNotNull(ReflectionTestUtils.getField(reader, "bis"));
    }
}
