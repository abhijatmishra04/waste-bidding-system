package com.bofa.sst.batch.core.impl;

import com.bofa.sst.batch.constants.CustaggSQLFactory;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class CustaggProcessorTest {

    @Mock
    private JdbcTemplate jdbcTemplate;

    @Mock
    private CustaggRecordsDTO input;

    private HashMap<String, String> entityMap;

    @InjectMocks
    private CustaggProcessor processor;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);

        // Initialize entity map
        entityMap = new HashMap<>();
        entityMap.put("ENTITY1", "MAPPED_ENTITY1");

        // Create processor with mocked entity map
        processor = new CustaggProcessor(entityMap);

        // Initialize mock input
        when(input.getEntity()).thenReturn("ENTITY1");
        when(input.getAccountNumber()).thenReturn("ACC12345");
        when(input.getProductCode()).thenReturn("PROD01");
    }

    @Test
    public void testProcess_SuccessfulProcessing() throws Exception {
        // Arrange
        List<String> mockScheduleIds = Arrays.asList("SCHED123");
        List<String> mockTransferExecutionIds = Arrays.asList("EXEC456");

        when(jdbcTemplate.queryForObject(eq(CustaggSQLFactory.FETCH_SCHEDULE_ID_ACCOUNT_BOA), eq(String.class), any()))
                .thenReturn("SCHED123");
        when(jdbcTemplate.queryForObject(eq(CustaggSQLFactory.FETCH_TRANSFER_EXECUTION_M2M_ID), eq(String.class), any()))
                .thenReturn("EXEC456");

        doAnswer(invocation -> null).when(jdbcTemplate).batchUpdate(eq(CustaggSQLFactory.UPDATE_TRANSFER_EXECUTION_M2M),
                anyList(), anyInt(), any());

        // Act
        CustaggProcessedRecordsDTO result = processor.process(input);

        // Assert
        assertNotNull(result);
        assertEquals("MAPPED_ENTITY1", result.getMappedEntity());
        assertEquals("ENTITY1", result.getNumEntity());
        assertEquals("ACC12345", result.getAccountNumber());
        assertEquals("PROD01", result.getProductCode());
        assertTrue(result.getScheduleIds().contains("SCHED123"));
        assertTrue(result.getTransferExecutionIds().contains("EXEC456"));

        // Verify database interactions
        verify(jdbcTemplate, times(1)).queryForObject(eq(CustaggSQLFactory.FETCH_SCHEDULE_ID_ACCOUNT_BOA), eq(String.class), any());
        verify(jdbcTemplate, times(1)).queryForObject(eq(CustaggSQLFactory.FETCH_TRANSFER_EXECUTION_M2M_ID), eq(String.class), any());
        verify(jdbcTemplate, times(1)).batchUpdate(eq(CustaggSQLFactory.UPDATE_TRANSFER_EXECUTION_M2M), anyList(), anyInt(), any());
    }

    @Test(expected = IllegalStateException.class)
    public void testProcess_EmptyEntityMap() throws Exception {
        // Arrange
        entityMap.clear();
        processor = new CustaggProcessor(entityMap);

        // Act
        processor.process(input);
    }

    @Test
    public void testProcess_NoMatchInEntityMap() throws Exception {
        // Arrange
        when(input.getEntity()).thenReturn("UNKNOWN_ENTITY");

        // Act
        CustaggProcessedRecordsDTO result = processor.process(input);

        // Assert
        assertNull(result);
        verifyZeroInteractions(jdbcTemplate);
    }

    @Test
    public void testProcess_FetchScheduledFails() throws Exception {
        // Arrange
        when(jdbcTemplate.queryForObject(eq(CustaggSQLFactory.FETCH_SCHEDULE_ID_ACCOUNT_BOA), eq(String.class), any()))
                .thenThrow(new RuntimeException("Database error"));

        // Act
        CustaggProcessedRecordsDTO result = processor.process(input);

        // Assert
        assertNotNull(result);
        assertTrue(result.getScheduleIds().isEmpty());
    }

    @Test
    public void testProcess_FetchTransferExecutionIdFails() throws Exception {
        // Arrange
        when(jdbcTemplate.queryForObject(eq(CustaggSQLFactory.FETCH_SCHEDULE_ID_ACCOUNT_BOA), eq(String.class), any()))
                .thenReturn("SCHED123");
        when(jdbcTemplate.queryForObject(eq(CustaggSQLFactory.FETCH_TRANSFER_EXECUTION_M2M_ID), eq(String.class), any()))
                .thenThrow(new RuntimeException("Transfer Execution Fetch Failed"));

        // Act
        CustaggProcessedRecordsDTO result = processor.process(input);

        // Assert
        assertNotNull(result);
        assertTrue(result.getTransferExecutionIds().isEmpty());
    }

    @Test
    public void testProcess_FetchTransferInstructionIdFails() throws Exception {
        // Arrange
        when(jdbcTemplate.queryForObject(eq(CustaggSQLFactory.FETCH_SCHEDULE_ID_ACCOUNT_BOA), eq(String.class), any()))
                .thenReturn("SCHED123");
        when(jdbcTemplate.queryForObject(eq(CustaggSQLFactory.FETCH_TRANSFER_EXECUTION_M2M_ID), eq(String.class), any()))
                .thenReturn("EXEC456");
        when(jdbcTemplate.queryForObject(eq(CustaggSQLFactory.FETCH_TRANSFER_INSTRUCTION_ID), eq(String.class), any()))
                .thenThrow(new RuntimeException("Transfer Instruction Fetch Failed"));

        doAnswer(invocation -> null).when(jdbcTemplate).batchUpdate(eq(CustaggSQLFactory.UPDATE_TRANSFER_EXECUTION_M2M),
                anyList(), anyInt(), any());

        // Act
        CustaggProcessedRecordsDTO result = processor.process(input);

        // Assert
        assertNotNull(result);
        assertTrue(result.getTransferExecutionIds().contains("EXEC456"));
    }
}
