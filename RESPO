package com.bofa.sst.batch.core.impl;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.MockedStatic;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.scope.context.ExecutionContext;

@RunWith(MockitoJUnitRunner.class)
public class CustaggFileValidationTaskletTest {

    private CustaggFileValidationTasklet tasklet;

    @Mock
    private StepContribution stepContribution;
    
    @Mock
    private ChunkContext chunkContext;
    
    @Mock
    private StepExecution stepExecution;
    
    @Mock
    private JobExecution jobExecution;
    
    @Mock
    private ExecutionContext executionContext;
    
    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        tasklet = new CustaggFileValidationTasklet();
        
        when(stepContribution.getStepExecution()).thenReturn(stepExecution);
        when(stepExecution.getJobExecution()).thenReturn(jobExecution);
        when(jobExecution.getExecutionContext()).thenReturn(executionContext);
    }

    @Test
    public void testExecute_Success() throws Exception {
        try (MockedStatic<FileUtils> fileUtilsMock = mockStatic(FileUtils.class)) {
            // Mock directory paths and file names
            when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn("mockDir");
            when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA)).thenReturn("referData");
            when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn("referEntry");

            fileUtilsMock.when(() -> FileUtils.findTodaysFiles("mockDir", "referData", CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn("mockDir/mockFile1.dat");
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles("mockDir", "referEntry", CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn("mockDir/mockFile2.dat");

            fileUtilsMock.when(() -> FileUtils.lockFile(anyString(), anyString(), anyString())).thenReturn(true);

            fileUtilsMock.when(() -> FileUtils.findTodaysFiles("mockDir", "referEntry", CustaggBatchConstants.LOCK_FILE_EXTENSION))
                    .thenReturn("mockDir/mockFile2.lock");

            // Mock BufferedReader behavior
            try (MockedStatic<FileReader> fileReaderMock = mockStatic(FileReader.class);
                 MockedStatic<BufferedReader> bufferedReaderMock = mockStatic(BufferedReader.class)) {
                
                BufferedReader mockReader = mock(BufferedReader.class);
                when(mockReader.readLine()).thenReturn("ABCD1234", null); // Mock valid line, then end of file

                fileReaderMock.when(() -> new FileReader("mockDir/mockFile2.lock")).thenReturn(mock(FileReader.class));
                bufferedReaderMock.when(() -> new BufferedReader(any(FileReader.class))).thenReturn(mockReader);

                // Execute tasklet
                RepeatStatus status = tasklet.execute(stepContribution, chunkContext);
                assertEquals(RepeatStatus.FINISHED, status);
                verify(stepContribution).setExitStatus(ExitStatus.COMPLETED);
            }
        }
    }

    @Test(expected = FileNotFoundException.class)
    public void testExecute_FileNotFound() throws Exception {
        try (MockedStatic<FileUtils> fileUtilsMock = mockStatic(FileUtils.class)) {
            when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn("mockDir");
            when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA)).thenReturn("referData");
            when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn("referEntry");

            fileUtilsMock.when(() -> FileUtils.findTodaysFiles("mockDir", "referData", CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn(null);
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles("mockDir", "referEntry", CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn(null);

            tasklet.execute(stepContribution, chunkContext);
        }
    }

    @Test(expected = Exception.class)
    public void testExecute_IOExceptionHandling() throws Exception {
        try (MockedStatic<FileUtils> fileUtilsMock = mockStatic(FileUtils.class)) {
            when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn("mockDir");
            when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn("referEntry");

            fileUtilsMock.when(() -> FileUtils.findTodaysFiles("mockDir", "referEntry", CustaggBatchConstants.LOCK_FILE_EXTENSION))
                    .thenReturn("mockDir/mockFile2.lock");

            try (MockedStatic<FileReader> fileReaderMock = mockStatic(FileReader.class);
                 MockedStatic<BufferedReader> bufferedReaderMock = mockStatic(BufferedReader.class)) {

                fileReaderMock.when(() -> new FileReader("mockDir/mockFile2.lock")).thenThrow(new IOException());

                tasklet.execute(stepContribution, chunkContext);
            }
        }
    }

    @Test
    public void testExecute_LockFileExceptionHandling() throws Exception {
        try (MockedStatic<FileUtils> fileUtilsMock = mockStatic(FileUtils.class)) {
            when(executionContext.getString(CustaggBatchConstants.DIRECTORY_PATH)).thenReturn("mockDir");
            when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA)).thenReturn("referData");
            when(executionContext.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTRY)).thenReturn("referEntry");

            fileUtilsMock.when(() -> FileUtils.findTodaysFiles("mockDir", "referData", CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn("mockDir/mockFile1.dat");
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles("mockDir", "referEntry", CustaggBatchConstants.INPUT_FILE_EXTENSION))
                    .thenReturn("mockDir/mockFile2.dat");

            fileUtilsMock.when(() -> FileUtils.lockFile(anyString(), anyString(), anyString())).thenThrow(new RuntimeException("Lock failed"));

            try {
                tasklet.execute(stepContribution, chunkContext);
            } catch (Exception e) {
                assertTrue(e.getMessage().contains("Lock failed"));
            }
        }
    }
}
