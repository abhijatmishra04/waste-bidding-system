package com.bofa.sst.batch.core.impl;

import com.bofa.sst.batch.model.CustaggRecordsDTO;
import org.junit.*;
import org.springframework.batch.item.ExecutionContext;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;

import static org.junit.Assert.*;

public class CustagCompFileReaderTest {

    private CustagCompFileReader fileReader;
    private ExecutionContext executionContext;
    private Path testFilePath;

    @Before
    public void setUp() throws Exception {
        fileReader = new CustagCompFileReader();
        executionContext = new ExecutionContext();

        // Create a temporary test file
        testFilePath = Files.createTempFile("test-input", ".txt");
        String sampleData = "PROD01ENTITY001ACC123456789012345\n"
                          + "PROD02ENTITY002ACC987654321098765\n";
        Files.write(testFilePath, sampleData.getBytes(), StandardOpenOption.WRITE);

        fileReader.inputFilePath = testFilePath.toString();
    }

    @Test
    public void testOpenAndRead_Success() throws Exception {
        executionContext.putInt("fromLine", 1);
        executionContext.putInt("toLine", 2);

        try {
            fileReader.open(executionContext);

            CustaggRecordsDTO record1 = fileReader.read();
            assertNotNull("First record should not be null", record1);
            assertEquals("PROD01", record1.getProductCode());
            assertEquals("ENTITY001", record1.getEntity());
            assertEquals("ACC123456789012345", record1.getAccountNumber());

            CustaggRecordsDTO record2 = fileReader.read();
            assertNotNull("Second record should not be null", record2);
            assertEquals("PROD02", record2.getProductCode());
            assertEquals("ENTITY002", record2.getEntity());
            assertEquals("ACC987654321098765", record2.getAccountNumber());

            assertNull("No more records expected", fileReader.read());
        } finally {
            fileReader.close(); // Ensure cleanup
        }
    }

    @Test(expected = RuntimeException.class)
    public void testRead_IncompleteRecord() throws Exception {
        Files.write(testFilePath, "INCOMPLETE".getBytes(), StandardOpenOption.APPEND);

        executionContext.putInt("fromLine", 1);
        executionContext.putInt("toLine", 3);

        try {
            fileReader.open(executionContext);
            fileReader.read(); // Valid record
            fileReader.read(); // Valid record
            fileReader.read(); // Incomplete record - should throw exception
        } finally {
            fileReader.close(); // Cleanup
        }
    }

    @Test(expected = RuntimeException.class)
    public void testOpen_FileNotFound() throws Exception {
        fileReader.inputFilePath = "non-existent-file.txt";
        fileReader.open(executionContext);
    }

    @Test
    public void testUpdateExecutionContext() throws Exception {
        executionContext.putInt("fromLine", 1);
        executionContext.putInt("toLine", 1);

        try {
            fileReader.open(executionContext);
            fileReader.read();
            fileReader.update(executionContext);

            assertEquals("ExecutionContext counter should be updated", 1, executionContext.getInt("counter"));
        } finally {
            fileReader.close(); // Cleanup
        }
    }

    @After
    public void tearDown() throws Exception {
        // Ensure the stream is closed
        if (fileReader != null) {
            fileReader.close();
        }
        // Safely delete the temporary file
        if (Files.exists(testFilePath)) {
            Files.deleteIfExists(testFilePath);
        }
    }
}
