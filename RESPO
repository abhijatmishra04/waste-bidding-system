package com.bofa.sst.batch.core.impl;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.util.HashMap;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.repeat.RepeatStatus;

@RunWith(MockitoJUnitRunner.class)
public class CustaggFileValidationTaskletTest {

    public static class CustaggBatchConstants {
        public static final String DIRECTORY_PATH = "DIRECTORY_PATH";
        public static final String FILE_PREFIX_REFERDATA = "FILE_PREFIX_REFERDATA";
        public static final String FILE_PREFIX_REFERENTRY = "FILE_PREFIX_REFERENTRY";
        public static final String INPUT_FILE_EXTENSION = ".dat";
        public static final String LOCK_FILE_EXTENSION = ".lck";
    }

    private CustaggFileValidationTasklet tasklet = new CustaggFileValidationTasklet();
    private StepContribution stepContribution = mock(StepContribution.class);
    private StepExecution stepExecution = mock(StepExecution.class);
    private JobExecution jobExecution = mock(JobExecution.class);
    private ChunkContext chunkContext = mock(ChunkContext.class);

    private ExecutionContext createExecutionContext(String directory, String dataPrefix, String entryPrefix) {
        ExecutionContext context = new ExecutionContext();
        context.put(CustaggBatchConstants.DIRECTORY_PATH, directory);
        context.put(CustaggBatchConstants.FILE_PREFIX_REFERDATA, dataPrefix);
        context.put(CustaggBatchConstants.FILE_PREFIX_REFERENTRY, entryPrefix);
        return context;
    }

    private void setupStepContribution(ExecutionContext executionContext) {
        when(stepContribution.getStepExecution()).thenReturn(stepExecution);
        when(stepExecution.getJobExecution()).thenReturn(jobExecution);
        when(jobExecution.getExecutionContext()).thenReturn(executionContext);
    }

    @Test
    public void testExecute_success() throws Exception {
        File tempLockedFile = File.createTempFile("tempLockedFile", CustaggBatchConstants.LOCK_FILE_EXTENSION);
        tempLockedFile.deleteOnExit();
        try (PrintWriter writer = new PrintWriter(tempLockedFile)) {
            writer.println("ABCD1234");
            writer.println("WXYZ5678");
            writer.println("short");
            writer.println("    0000");
            writer.println("LMNO    ");
        }

        String directoryPath = "dummyDir";
        String dataPrefix = "data";
        String entryPrefix = "entry";

        ExecutionContext executionContext = createExecutionContext(directoryPath, dataPrefix, entryPrefix);
        setupStepContribution(executionContext);

        try (var fileUtilsMock = Mockito.mockStatic(FileUtils.class)) {
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(dataPrefix),
                    eq(CustaggBatchConstants.INPUT_FILE_EXTENSION))).thenReturn("dummyDataFile.dat");
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(entryPrefix),
                    eq(CustaggBatchConstants.INPUT_FILE_EXTENSION))).thenReturn("dummyEntryFile.dat");
            fileUtilsMock.when(() -> FileUtils.lockFile(anyString(), anyString(), anyString()))
                    .thenAnswer(invocation -> null);
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(entryPrefix),
                    eq(CustaggBatchConstants.LOCK_FILE_EXTENSION))).thenReturn(tempLockedFile.getAbsolutePath());

            RepeatStatus status = tasklet.execute(stepContribution, chunkContext);
            assertEquals(RepeatStatus.FINISHED, status);

            Object entityMapObj = executionContext.get("entityMap");
            assertNotNull(entityMapObj);
            assertTrue(entityMapObj instanceof HashMap);
            @SuppressWarnings("unchecked")
            HashMap<String, String> entityMap = (HashMap<String, String>) entityMapObj;
            assertEquals(2, entityMap.size());
            assertEquals("ABCD", entityMap.get("1234"));
            assertEquals("WXYZ", entityMap.get("5678"));
        }
    }

    @Test(expected = FileNotFoundException.class)
    public void testExecute_fileNotFound() throws Exception {
        String directoryPath = "dummyDir";
        String dataPrefix = "data";
        String entryPrefix = "entry";

        ExecutionContext executionContext = createExecutionContext(directoryPath, dataPrefix, entryPrefix);
        setupStepContribution(executionContext);

        try (var fileUtilsMock = Mockito.mockStatic(FileUtils.class)) {
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(dataPrefix),
                    eq(CustaggBatchConstants.INPUT_FILE_EXTENSION))).thenReturn(null);
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(entryPrefix),
                    eq(CustaggBatchConstants.INPUT_FILE_EXTENSION))).thenReturn("dummyEntryFile.dat");

            tasklet.execute(stepContribution, chunkContext);
        }
    }

    @Test
    public void testExecute_lockFileException() throws Exception {
        File tempLockedFile = File.createTempFile("tempLockedFile", CustaggBatchConstants.LOCK_FILE_EXTENSION);
        tempLockedFile.deleteOnExit();
        try (PrintWriter writer = new PrintWriter(tempLockedFile)) {
            writer.println("QWER1111");
        }

        String directoryPath = "dummyDir";
        String dataPrefix = "data";
        String entryPrefix = "entry";

        ExecutionContext executionContext = createExecutionContext(directoryPath, dataPrefix, entryPrefix);
        setupStepContribution(executionContext);

        try (var fileUtilsMock = Mockito.mockStatic(FileUtils.class)) {
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(dataPrefix),
                    eq(CustaggBatchConstants.INPUT_FILE_EXTENSION))).thenReturn("dummyDataFile.dat");
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(entryPrefix),
                    eq(CustaggBatchConstants.INPUT_FILE_EXTENSION))).thenReturn("dummyEntryFile.dat");
            fileUtilsMock.when(() -> FileUtils.lockFile(anyString(), anyString(), anyString()))
                    .thenThrow(new RuntimeException("lock file error"));
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(entryPrefix),
                    eq(CustaggBatchConstants.LOCK_FILE_EXTENSION))).thenReturn(tempLockedFile.getAbsolutePath());

            RepeatStatus status = tasklet.execute(stepContribution, chunkContext);
            assertEquals(RepeatStatus.FINISHED, status);

            Object entityMapObj = executionContext.get("entityMap");
            assertNotNull(entityMapObj);
            @SuppressWarnings("unchecked")
            HashMap<String, String> entityMap = (HashMap<String, String>) entityMapObj;
            assertEquals(1, entityMap.size());
            assertEquals("QWER", entityMap.get("1111"));
        }
    }

    @Test
    public void testExecute_fileReadingIOException() throws Exception {
        File tempDir = Files.createTempDirectory("tempDir").toFile();
        tempDir.deleteOnExit();

        String directoryPath = "dummyDir";
        String dataPrefix = "data";
        String entryPrefix = "entry";

        ExecutionContext executionContext = createExecutionContext(directoryPath, dataPrefix, entryPrefix);
        setupStepContribution(executionContext);

        try (var fileUtilsMock = Mockito.mockStatic(FileUtils.class)) {
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(dataPrefix),
                    eq(CustaggBatchConstants.INPUT_FILE_EXTENSION))).thenReturn("dummyDataFile.dat");
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(entryPrefix),
                    eq(CustaggBatchConstants.INPUT_FILE_EXTENSION))).thenReturn("dummyEntryFile.dat");
            fileUtilsMock.when(() -> FileUtils.lockFile(anyString(), anyString(), anyString()))
                    .thenAnswer(invocation -> null);
            fileUtilsMock.when(() -> FileUtils.findTodaysFiles(eq(directoryPath), eq(entryPrefix),
                    eq(CustaggBatchConstants.LOCK_FILE_EXTENSION))).thenReturn(tempDir.getAbsolutePath());

            try {
                tasklet.execute(stepContribution, chunkContext);
                fail("Expected Exception due to file reading error");
            } catch (Exception e) {
                assertTrue(e.getMessage().contains("Error reading file"));
            }
        }
    }
}
