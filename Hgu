@Component
@StepScope
@Log4j2
public class CollectionLettersAggregatorTasklet implements Tasklet {

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        ExecutionContext context = contribution.getStepExecution().getJobExecution().getExecutionContext();

        String sourceDir = context.getString(CollectionLettersBatchConstants.PROPERTY_COLLECTIONLETTERS_OUTPUT_FILE_PATH_KEY);

        log.info(LoggingUtil.logJobMessage(
            "FILE_AGGREGATION",
            "SOURCE_DIR",
            "The file aggregator output directory path is set to: " + sourceDir
        ));

        validateDirectoryPath(sourceDir);

        List<String> letterTypes = List.of("NN3", "NN5", "NN8", "NN14", "NN28", "NN30");
        StringBuilder finalAggregatedContent = new StringBuilder();

        for (String letterType : letterTypes) {
            aggregateFilesForLetterType(sourceDir, letterType, finalAggregatedContent);
        }

        Path finalOutputPath = Paths.get(sourceDir).resolve("Final_Aggregated_Letter.txt");
        try {
            Files.write(finalOutputPath, finalAggregatedContent.toString().getBytes());
            log.info(LoggingUtil.logJobMessage(
                "FILE_AGGREGATION",
                "FINAL_OUTPUT",
                "Final aggregated letter written to file: " + finalOutputPath.getFileName()
            ));
        } catch (IOException e) {
            log.error(LoggingUtil.logJobMessage(
                "FILE_AGGREGATION",
                "WRITE_ERROR",
                "Error writing final aggregated letter to file: " + finalOutputPath.getFileName() + " | Error: " + e.getMessage()
            ));
            throw e;
        }

        return RepeatStatus.FINISHED;
    }

    public void validateDirectoryPath(String path) {
        if (path == null || path.trim().isEmpty()) {
            throw new IllegalStateException("File directory path must not be null or empty for file watcher configuration");
        }
    }

    public void aggregateFilesForLetterType(String sourceDir, String letterType, StringBuilder finalAggregatedContent) throws IOException {
        Path sourcePath = Paths.get(sourceDir).toAbsolutePath();

        log.info(LoggingUtil.logJobMessage(
            "FILE_AGGREGATION",
            letterType,
            "Resolved source path: " + sourcePath.toString()
        ));

        Pattern pattern = Pattern.compile(letterType + CollectionLettersBatchConstants.PATTERN_2);
        log.info(LoggingUtil.logJobMessage(
            "FILE_AGGREGATION",
            letterType,
            "Generated pattern for letter type: " + pattern
        ));

        try (Stream<Path> filesStream = Files.list(sourcePath)) {
            List<Path> matchingFiles = filesStream
                .filter(path -> pattern.matcher(path.getFileName().toString()).matches())
                .sorted()
                .collect(Collectors.toList());

            if (matchingFiles.isEmpty()) {
                log.warn(LoggingUtil.logJobMessage(
                    "FILE_AGGREGATION",
                    letterType,
                    "No files found for letter type"
                ));
                return;
            }

            StringBuilder aggregatedContent = new StringBuilder();
            String header = String.format(
                CollectionLettersBatchConstants.HEADER_FORMAT,
                LocalDateTime.now().format(CollectionLettersBatchConstants.HEADER_DATE_FORMAT)
            );

            aggregatedContent.append(header).append(System.lineSeparator());

            int totalRecordsCount = 0;

            for (Path filePath : matchingFiles) {
                try {
                    List<String> lines = Files.readAllLines(filePath);
                    if (lines.size() > 2) {
                        for (int i = 1; i < lines.size(); i++) {
                            aggregatedContent.append(lines.get(i)).append(System.lineSeparator());
                            totalRecordsCount++;
                        }
                    }
                } catch (IOException e) {
                    log.error(LoggingUtil.logJobMessage(
                        "FILE_AGGREGATION",
                        letterType,
                        "Error reading file: " + filePath.getFileName() + " | Error: " + e.getMessage()
                    ));
                }
            }

            String trailer = String.format(
                CollectionLettersBatchConstants.TRAILER_FORMAT,
                totalRecordsCount
            );
            aggregatedContent.append(trailer).append(System.lineSeparator());

            Path outputPath = sourcePath.resolve(letterType + "_Letter.txt");
            try {
                Files.write(outputPath, aggregatedContent.toString().getBytes());
                log.info(LoggingUtil.logJobMessage(
                    "FILE_AGGREGATION",
                    letterType,
                    "Aggregated content written to file: " + outputPath.getFileName()
                ));
            } catch (IOException e) {
                log.error(LoggingUtil.logJobMessage(
                    "FILE_AGGREGATION",
                    letterType,
                    "Error writing to output file: " + outputPath.getFileName() + " | Error: " + e.getMessage()
                ));
                throw e;
            }

            finalAggregatedContent.append(aggregatedContent).append(System.lineSeparator());

            // Delete temporary files
            for (Path filePath : matchingFiles) {
                if (!filePath.equals(outputPath)) {
                    try {
                        Files.delete(filePath);
                        log.info(LoggingUtil.logJobMessage(
                            "FILE_AGGREGATION",
                            letterType,
                            "Deleted temporary file: " + filePath.getFileName()
                        ));
                    } catch (NoSuchFileException e) {
                        log.warn(LoggingUtil.logJobMessage(
                            "FILE_AGGREGATION",
                            letterType,
                            "File not found: " + filePath.getFileName()
                        ));
                    } catch (IOException e) {
                        log.error(LoggingUtil.logJobMessage(
                            "FILE_AGGREGATION",
                            letterType,
                            "Error deleting file: " + filePath.getFileName() + " | Error: " + e.getMessage()
                        ));
                    }
                }
            }
        }
    }
}
