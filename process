import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import com.bofa.ept.sst.batch.dto.RetrievalDTO;
import org.springframework.batch.item.ItemProcessor;

@RunWith(MockitoJUnitRunner.class)
public class RetrievalDTOProcessorTest {

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyyMMdd");

    @InjectMocks
    private RetrievalDTOProcessor processor;

    @Mock
    private RetrievalDTO item;  // Mocked DTO to simulate input

    @Before
    public void setUp() {
        // Initialize Mockito
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testProcess_filteredOutBySubChannel() throws Exception {
        // Mock subChannel and statementBalance
        when(item.getSubChannel()).thenReturn("NOT_COL");
        when(item.getStatementBalance()).thenReturn("500.00");

        // Call the process method
        RetrievalDTO result = processor.process(item);

        // Since subChannel is not "COL", the result should be null (filtered out)
        assertNull(result);
    }

    @Test
    public void testProcess_filteredOutByStatementBalance() throws Exception {
        // Mock subChannel and statementBalance
        when(item.getSubChannel()).thenReturn("COL");
        when(item.getStatementBalance()).thenReturn("0.0");

        // Call the process method
        RetrievalDTO result = processor.process(item);

        // Since statementBalance is <= 0, the result should be null (filtered out)
        assertNull(result);
    }

    @Test
    public void testProcess_validRecordWeekday() throws Exception {
        // Mock a valid input with subChannel = "COL" and statementBalance > 0
        when(item.getSubChannel()).thenReturn("COL");
        when(item.getStatementBalance()).thenReturn("1000.00");
        when(item.getDueDate()).thenReturn("20240925"); // September 25, 2024 (a Wednesday)
        when(item.getPaymentType()).thenReturn("CREDIT");
        when(item.getAccountNumber()).thenReturn("ACC123");
        when(item.getConfirmationNumber()).thenReturn("CONFIRM456");
        when(item.getMarketId()).thenReturn("MARKET789");
        when(item.getCreateTimestamp()).thenReturn("20240101T120000");

        // Call the process method
        RetrievalDTO result = processor.process(item);

        // Assert that the result is not null (valid record)
        assertNotNull(result);

        // Assert the hanging days are calculated for a weekday
        assertEquals(5, result.getHangingDays());

        // Assert the other values are mapped correctly
        assertEquals("D", result.getDetailRecordId());
        assertEquals("CREDIT", result.getPaymentType());
        assertEquals("ACC123", result.getAccountNumber());
        assertEquals("CONFIRM456", result.getConfirmationNumber());
        assertEquals("20240925", result.getDueDate());
        assertEquals("MARKET789", result.getMarketId());
        assertEquals("20240101T120000", result.getCreateTimestamp());
    }

    @Test
    public void testProcess_validRecordSunday() throws Exception {
        // Mock a valid input with subChannel = "COL" and statementBalance > 0
        when(item.getSubChannel()).thenReturn("COL");
        when(item.getStatementBalance()).thenReturn("1000.00");
        when(item.getDueDate()).thenReturn("20240922"); // September 22, 2024 (a Sunday)
        when(item.getPaymentType()).thenReturn("CREDIT");
        when(item.getAccountNumber()).thenReturn("ACC123");
        when(item.getConfirmationNumber()).thenReturn("CONFIRM456");
        when(item.getMarketId()).thenReturn("MARKET789");
        when(item.getCreateTimestamp()).thenReturn("20240101T120000");

        // Call the process method
        RetrievalDTO result = processor.process(item);

        // Assert that the result is not null (valid record)
        assertNotNull(result);

        // Assert the hanging days are calculated for a Sunday
        assertEquals(6, result.getHangingDays()); // Sunday has an adjustment of 6 days

        // Assert the other values are mapped correctly
        assertEquals("D", result.getDetailRecordId());
        assertEquals("CREDIT", result.getPaymentType());
        assertEquals("ACC123", result.getAccountNumber());
        assertEquals("CONFIRM456", result.getConfirmationNumber());
        assertEquals("20240922", result.getDueDate());
        assertEquals("MARKET789", result.getMarketId());
        assertEquals("20240101T120000", result.getCreateTimestamp());
    }

    @Test
    public void testGetTotalRecordCount() {
        // Process a couple of valid records to increment the counter
        processor.process(item);
        processor.process(item);

        // Check that the record count matches the number of processed records
        assertEquals(2, RetrievalDTOProcessor.getTotalRecordCount());
    }
}



import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.runners.MockitoJUnitRunner;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;

import com.bofa.ept.sst.batch.dto.RetrievalDTO;

@RunWith(MockitoJUnitRunner.class)
public class HangingReportClassifierWriterTest {

    @InjectMocks
    private HangingReportClassifierWriter hangingReportClassifierWriter;

    @Mock
    private HangingReportWriter1 hangingReportWriter1;

    @Mock
    private ItemWriter<RetrievalDTO> mockItemWriter;  // Mock ItemWriter to simulate different routes

    private RetrievalDTO retrievalDTO;

    @Before
    public void setUp() {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);

        // Create a dummy RetrievalDTO instance
        retrievalDTO = new RetrievalDTO();

        // Use lenient() to ignore unused stubbings in some tests
        lenient().when(hangingReportWriter1.dayPlusOneWriter()).thenReturn(mockItemWriter);
        lenient().when(hangingReportWriter1.moreThan7DaysWriter()).thenReturn(mockItemWriter);
        lenient().when(hangingReportWriter1.moreThan25DaysWriter()).thenReturn(mockItemWriter);
    }

    @Test
    public void testClassifier_dayPlusOneWriter() throws Exception {
        // Set hangingDays to 1 in the DTO
        retrievalDTO.setHangingDays(1L);

        // Get the composite writer
        ClassifierCompositeItemWriter<RetrievalDTO> writer = hangingReportClassifierWriter.HangingReportFileClassifier();

        // Classify the DTO and check that it routes to dayPlusOneWriter
        ItemWriter<RetrievalDTO> classifiedWriter = writer.getClassifier().classify(retrievalDTO);
        assertNotNull(classifiedWriter);
        assertEquals(mockItemWriter, classifiedWriter);

        // Verify interaction with dayPlusOneWriter
        verify(hangingReportWriter1).dayPlusOneWriter();
    }

    @Test
    public void testClassifier_moreThan7DaysWriter() throws Exception {
        // Set hangingDays to 10 in the DTO
        retrievalDTO.setHangingDays(10L);

        // Get the composite writer
        ClassifierCompositeItemWriter<RetrievalDTO> writer = hangingReportClassifierWriter.HangingReportFileClassifier();

        // Classify the DTO and check that it routes to moreThan7DaysWriter
        ItemWriter<RetrievalDTO> classifiedWriter = writer.getClassifier().classify(retrievalDTO);
        assertNotNull(classifiedWriter);
        assertEquals(mockItemWriter, classifiedWriter);

        // Verify interaction with moreThan7DaysWriter
        verify(hangingReportWriter1).moreThan7DaysWriter();
    }

    @Test
    public void testClassifier_moreThan25DaysWriter() throws Exception {
        // Set hangingDays to 26 in the DTO
        retrievalDTO.setHangingDays(26L);

        // Get the composite writer
        ClassifierCompositeItemWriter<RetrievalDTO> writer = hangingReportClassifierWriter.HangingReportFileClassifier();

        // Classify the DTO and check that it routes to moreThan25DaysWriter
        ItemWriter<RetrievalDTO> classifiedWriter = writer.getClassifier().classify(retrievalDTO);
        assertNotNull(classifiedWriter);
        assertEquals(mockItemWriter, classifiedWriter);

        // Verify interaction with moreThan25DaysWriter
        verify(hangingReportWriter1).moreThan25DaysWriter();
    }

    @Test
    public void testClassifier_noWriter() throws Exception {
        // Set hangingDays to a value that doesn't match any writer (e.g., 0)
        retrievalDTO.setHangingDays(0L);

        // Get the composite writer
        ClassifierCompositeItemWriter<RetrievalDTO> writer = hangingReportClassifierWriter.HangingReportFileClassifier();

        // Classify the DTO and check that it routes to null (no writer)
        ItemWriter<RetrievalDTO> classifiedWriter = writer.getClassifier().classify(retrievalDTO);
        assertNull(classifiedWriter);
    }
}


import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.util.Collections;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.support.ClassifierCompositeItemWriter;

import com.bofa.ept.sst.batch.dto.RetrievalDTO;

@RunWith(MockitoJUnitRunner.class)
public class HangingReportClassifierWriterTest {

    @InjectMocks
    private HangingReportClassifierWriter hangingReportClassifierWriter;

    @Mock
    private HangingReportWriter1 hangingReportWriter1;

    @Mock
    private ItemWriter<RetrievalDTO> mockItemWriter;  // Mock ItemWriter to simulate different routes

    private RetrievalDTO retrievalDTO;

    @Before
    public void setUp() {
        // Initialize mocks
        MockitoAnnotations.initMocks(this);

        // Create a dummy RetrievalDTO instance
        retrievalDTO = new RetrievalDTO();

        // Use lenient() to ignore unused stubbings in some tests
        lenient().when(hangingReportWriter1.dayPlusOneWriter()).thenReturn(mockItemWriter);
        lenient().when(hangingReportWriter1.moreThan7DaysWriter()).thenReturn(mockItemWriter);
        lenient().when(hangingReportWriter1.moreThan25DaysWriter()).thenReturn(mockItemWriter);
    }

    @Test
    public void testClassifier_dayPlusOneWriter() throws Exception {
        // Set hangingDays to 1 in the DTO
        retrievalDTO.setHangingDays(1L);

        // Get the composite writer
        ClassifierCompositeItemWriter<RetrievalDTO> writer = hangingReportClassifierWriter.HangingReportFileClassifier();
        
        // Apply the classification by calling the write() method on the composite writer
        writer.write(Collections.singletonList(retrievalDTO));

        // Verify interaction with dayPlusOneWriter
        verify(hangingReportWriter1).dayPlusOneWriter();
    }

    @Test
    public void testClassifier_moreThan7DaysWriter() throws Exception {
        // Set hangingDays to 10 in the DTO
        retrievalDTO.setHangingDays(10L);

        // Get the composite writer and apply the classification logic
        ClassifierCompositeItemWriter<RetrievalDTO> writer = hangingReportClassifierWriter.HangingReportFileClassifier();
        writer.write(Collections.singletonList(retrievalDTO));

        // Verify interaction with moreThan7DaysWriter
        verify(hangingReportWriter1).moreThan7DaysWriter();
    }

    @Test
    public void testClassifier_moreThan25DaysWriter() throws Exception {
        // Set hangingDays to 26 in the DTO
        retrievalDTO.setHangingDays(26L);

        // Get the composite writer and apply the classification logic
        ClassifierCompositeItemWriter<RetrievalDTO> writer = hangingReportClassifierWriter.HangingReportFileClassifier();
        writer.write(Collections.singletonList(retrievalDTO));

        // Verify interaction with moreThan25DaysWriter
        verify(hangingReportWriter1).moreThan25DaysWriter();
    }

    @Test
    public void testClassifier_noWriter() throws Exception {
        // Set hangingDays to a value that doesn't match any writer (e.g., 0)
        retrievalDTO.setHangingDays(0L);

        // Get the composite writer and apply the classification logic
        ClassifierCompositeItemWriter<RetrievalDTO> writer = hangingReportClassifierWriter.HangingReportFileClassifier();
        writer.write(Collections.singletonList(retrievalDTO));

        // Since no writer should be invoked, verify that none of the writers are called
        verify(hangingReportWriter1, never()).dayPlusOneWriter();
        verify(hangingReportWriter1, never()).moreThan7DaysWriter();
        verify(hangingReportWriter1, never()).moreThan25DaysWriter();
    }
}


import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.listener.JobExecutionListenerSupport;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class SdpRespJobListener extends JobExecutionListenerSupport {

    @Override
    public void beforeJob(JobExecution jobExecution) {
        Log.trace("SdpRespJobListener ::: beforeJob ::: Entry");

        ExecutionContext context = jobExecution.getExecutionContext(); // Fetch the ExecutionContext

        try {
            exceptionWriter.initFileProperties();
            exceptionWriter.writeHeader();
        } catch (IOException e) {
            Log.error("SdpRespJobListener ::: beforeJob ::: Exception in creating exception file");
            jobExecution.setExitStatus(new ExitStatus("FAILED", "Exception File Creation Issue"));
        }

        String customerType = jobExecution.getJobParameters().getString(SdpRespConstants.JOB_TYPE);

        // Fetch paths dynamically from DynamicConfigPropertiesRepository
        String bacardiFilePath = dynamicConfigPropertiesRepository
            .findPropertyValueByPropertyName(SdpRespConstants.BACARDI_FILE_DIRECTORY_PATH);
        String requestFilePath = dynamicConfigPropertiesRepository
            .findPropertyValueByPropertyName(SdpRespConstants.SDP_REQUEST_DIRECTORY_PATH);

        String jobID = jobExecution.getJobId().toString();
        context.putString(SdpRespConstants.JOB_ID, jobID);

        context.putString(SdpRespConstants.BACARDI_RESPONSE_DIRECTORY_PATH, bacardiFilePath);
        context.putString(SdpRespConstants.SDP_REQUEST_DIRECTORY_PATH, requestFilePath);

        if (SdpRespConstants.CONSUMER.equalsIgnoreCase(customerType)) {
            context.putString(SdpRespConstants.BACARDI_RESPONSE_FILE_PREFIX, 
                dynamicConfigPropertiesRepository.findPropertyValueByPropertyName(SdpRespConstants.BACARDI_CONSUMER_FILE_PREFIX));
            context.putString(SdpRespConstants.SDP_REQUEST_FILE_PREFIX, 
                SdpRespConstants.CONSUMER_SDPREQUEST_FILE_PREFIX);
        } else {
            context.putString(SdpRespConstants.BACARDI_RESPONSE_FILE_PREFIX, 
                dynamicConfigPropertiesRepository.findPropertyValueByPropertyName(SdpRespConstants.BACARDI_SMB_FILE_PREFIX));
            context.putString(SdpRespConstants.SDP_REQUEST_FILE_PREFIX, 
                SdpRespConstants.SMB_SDPREQUEST_FILE_PREFIX);
        }

        // Set the output file path dynamically for the hanging report
        String hangingReportFilePath = dynamicConfigPropertiesRepository
            .findPropertyValueByPropertyName("sdphanging.output.flat.file.path"); // Replace with the actual config key

        if (hangingReportFilePath != null) {
            context.putString("sdphanging.output.flat.file.path", hangingReportFilePath);  // Set the execution context
            Log.info("Hanging report file path set in ExecutionContext: {}", hangingReportFilePath);
        } else {
            Log.error("Failed to fetch the hanging report file path from DynamicConfigPropertiesRepository.");
            jobExecution.setExitStatus(new ExitStatus("FAILED", "Missing Hanging Report File Path"));
        }

        Log.trace("SdpRespJobListener ::: beforeJob ::: Exit");
    }
}




import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.stereotype.Component;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.*;
import java.nio.file.*;
import java.util.List;

@Component
public class HangingReportFileAggregator {

    private static final Logger logger = LogManager.getLogger(HangingReportFileAggregator.class);

    public void aggregateFiles(StepExecution stepExecution) throws IOException {
        JobExecution jobExecution = stepExecution.getJobExecution();
        ExecutionContext context = jobExecution.getExecutionContext();

        // Fetch the output directory path from the ExecutionContext
        String directoryPath = context.getString("sdphanging.output.flat.file.path");
        if (directoryPath == null || directoryPath.isEmpty()) {
            logger.error("Hanging report file path is missing or empty in ExecutionContext.");
            throw new IllegalArgumentException("File path not available in ExecutionContext.");
        }

        // Define input files based on the writers' outputs
        String dayPlusOneWriterFile = directoryPath + "/dayPlusOneWriter.txt";
        String moreThan7DaysWriterFile = directoryPath + "/moreThan7DaysWriter.txt";
        String moreThan25DaysWriterFile = directoryPath + "/moreThan25DaysWriter.txt";

        // Define the output file (hanging report)
        String outputFilePath = directoryPath + "/hangingReport.txt";

        logger.info("Aggregating files into: {}", outputFilePath);

        // Aggregating files into the output
        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(outputFilePath), StandardOpenOption.CREATE)) {
            // Process each file and append its content to the output file
            List<String> filesToAggregate = List.of(dayPlusOneWriterFile, moreThan7DaysWriterFile, moreThan25DaysWriterFile);
            for (String filePath : filesToAggregate) {
                appendFileContent(filePath, writer);
            }

            logger.info("File aggregation complete. Output written to {}", outputFilePath);
        } catch (IOException e) {
            logger.error("Error occurred during file aggregation: {}", e.getMessage());
            throw e;
        }
    }

    private void appendFileContent(String inputFilePath, BufferedWriter writer) throws IOException {
        Path path = Paths.get(inputFilePath);

        // Check if the file exists before attempting to read
        if (Files.exists(path)) {
            try (BufferedReader reader = Files.newBufferedReader(path)) {
                String line;
                while ((line = reader.readLine()) != null) {
                    writer.write(line);
                    writer.newLine();
                }
                writer.flush();  // Ensure data is written to output file
            } catch (IOException e) {
                logger.error("Error reading file {}: {}", inputFilePath, e.getMessage());
                throw e;
            }
        } else {
            logger.warn("Input file {} does not exist. Skipping.", inputFilePath);
        }
    }
}
