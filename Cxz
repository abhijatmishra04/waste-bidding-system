#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RAI Gateway smoke test (ALL config embedded in this file)
- Uses PAT-style fields exactly like your sample: host, auth_type=pat, rai_client_id,
  eam_consumer_key, eam_consumer_secret, api_version, cloud_provider=azure
- No [routes] section; assumes the gateway exposes server-managed route names
  like "azure-openai.gpt-4o" / "azure-openai.gpt4-32k", etc.

Usage:
  python rai_smoketest_embedded.py
"""

import sys
import tempfile
import textwrap

# ======== FILL THESE WITH YOUR REAL VALUES (TEST ONLY—DO NOT COMMIT) =========
HOST                = "https://<your-rai-host>"   # e.g., https://api-uat.statestr.com/
AUTH_TYPE           = "pat"
RAI_CLIENT_ID       = "<your_rai_client_id>"
EAM_CONSUMER_KEY    = "<your_eam_consumer_key>"
EAM_CONSUMER_SECRET = "<your_eam_consumer_secret>"
API_VERSION         = "1.0"
CLOUD_PROVIDER      = "azure"                      # per your screenshot

# Pick a server-managed route name that your gateway exposes (see cli.model.search()).
MODEL_NAME          = "azure-openai.gpt-4o"
USER_PROMPT         = "ping"
# ============================================================================


def _write_temp_cfg() -> str:
    """Create a temp config file in the exact key=value style your gateway expects."""
    cfg_text = textwrap.dedent(f"""\
    host={HOST}
    auth_type={AUTH_TYPE}
    rai_client_id={RAI_CLIENT_ID}
    eam_consumer_key={EAM_CONSUMER_KEY}
    eam_consumer_secret={EAM_CONSUMER_SECRET}
    api_version={API_VERSION}
    cloud_provider={CLOUD_PROVIDER}
    """)
    tf = tempfile.NamedTemporaryFile(delete=False, suffix=".cfg")
    tf.write(cfg_text.encode("utf-8"))
    tf.flush()
    tf.close()
    return tf.name


def _content_to_text(content):
    """Handles string or OpenAI-style `content=[{type:'text', text:'...'}]`."""
    if isinstance(content, str):
        return content
    if isinstance(content, list) and content and isinstance(content[0], dict):
        return content[0].get("text", str(content[0]))
    return str(content)


def main():
    try:
        cfg_path = _write_temp_cfg()

        # Import here so any SDK issues are shown clearly
        from ssrai import SSRAIClient

        cli = SSRAIClient(config_file=cfg_path)

        # Optional: list available routes exposed by the gateway
        lister = getattr(cli.model, "search", None) or getattr(cli.model, "list", None)
        if callable(lister):
            try:
                available = lister()
                print("Available routes from gateway:", available)
            except Exception:
                pass  # not fatal if the method isn't supported on your build

        # Messages in the same shape your colleague used
        messages = [
            {"role": "system", "content": "Reply with the single token 'pong'."},
            {"role": "user",   "content": [{"type": "text", "text": USER_PROMPT}]},
        ]

        # One tiny chat call
        resp = cli.chat.create(
            model=MODEL_NAME,         # server-managed route name
            messages=messages,
            max_tokens=16,
            temperature=0.0,
            n=1,
        )

        choice = resp["choices"][0]["message"]
        text = _content_to_text(choice.get("content", ""))

        print("\n=== Gateway reply ===")
        print(text)

        if "pong" in text.lower():
            print("\n✅ RAI model call succeeded.")
            sys.exit(0)
        else:
            print("\n⚠️ Got a response, but not 'pong'. The route works; guardrails/policies may be altering text.")
            sys.exit(0)

    except Exception as e:
        print(f"❌ Smoke test failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
