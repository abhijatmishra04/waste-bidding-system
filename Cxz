#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
RAI Gateway client with Locust-based latency metrics.
-----------------------------------------------------
- SSRAI SDK untouched
- Retries + exponential backoff + circuit breaker
- Timing measured inside LocustMetrics
- Locust totals (avg/p50/p95/success rate) update correctly
- JSONL logging for events and metrics
"""

import os
import atexit
import time
import json
import random
import logging
import threading
from logging.handlers import RotatingFileHandler
from typing import Any, Callable, Dict, List, Optional, Tuple

os.environ.setdefault("LOCUST_NO_MONKEY_PATCH", "1")

from locust.env import Environment
from locust.event import EventHook
from ssrai import SSRAIClient


def setup_rot_logger(name: str, path: str) -> logging.Logger:
    """Create a rotating logger that writes plain JSON lines."""
    lg = logging.getLogger(name)
    lg.setLevel(logging.INFO)
    lg.propagate = False
    abs_path = os.path.abspath(path)
    os.makedirs(os.path.dirname(abs_path), exist_ok=True)
    if not any(isinstance(h, RotatingFileHandler) for h in lg.handlers):
        fh = RotatingFileHandler(abs_path, maxBytes=10 * 1024 * 1024, backupCount=3)
        fh.setFormatter(logging.Formatter("%(message)s"))
        lg.addHandler(fh)
    return lg


class CircuitBreaker:
    """Thread-safe circuit breaker controlling API access after repeated failures."""

    def __init__(self, fail_threshold: int = 10, half_open_after: float = 30.0):
        self.state = "CLOSED"
        self.fail_count = 0
        self.opened_at = 0.0
        self.fail_threshold = fail_threshold
        self.half_open_after = half_open_after
        self._lock = threading.Lock()

    def allow(self) -> bool:
        """Return True if calls are permitted based on breaker state."""
        with self._lock:
            if self.state == "OPEN" and (time.time() - self.opened_at) > self.half_open_after:
                self.state = "HALF_OPEN"
            return self.state != "OPEN"

    def on_success(self) -> None:
        """Reset breaker to CLOSED after successful call."""
        with self._lock:
            self.fail_count = 0
            self.state = "CLOSED"

    def on_failure(self) -> None:
        """Increment failure count and open breaker when threshold reached."""
        with self._lock:
            self.fail_count += 1
            if self.fail_count >= self.fail_threshold:
                self.state = "OPEN"
                self.opened_at = time.time()


class LocustMetrics:
    """Standalone Locust environment for latency and success metrics."""

    def __init__(self, request_type: str = "SSRAI"):
        self.env = Environment(user_classes=[])
        self.env.create_local_runner()
        self.request_type = request_type
        self.sample: EventHook = EventHook()
        self._attach_listener()

    def _attach_listener(self) -> None:
        """Attach listener that maps samples into Locustâ€™s request stats."""
        def _on_sample(name: str, latency_ms: float, success: bool, error: Optional[str] = None):
            if success:
                try:
                    self.env.events.request.fire(
                        request_type=self.request_type,
                        name=name,
                        response_time=float(latency_ms),
                        response_length=0,
                        exception=None,
                    )
                except TypeError:
                    self.env.events.request.fire(
                        request_type=self.request_type,
                        name=name,
                        response_time=float(latency_ms),
                        exception=None,
                    )
            else:
                err = RuntimeError(error or "error")
                try:
                    self.env.events.request.fire(
                        request_type=self.request_type,
                        name=name,
                        response_time=float(latency_ms),
                        response_length=0,
                        exception=err,
                    )
                except TypeError:
                    self.env.events.request.fire(
                        request_type=self.request_type,
                        name=name,
                        response_time=float(latency_ms),
                        exception=err,
                    )
        self.sample.add_listener(_on_sample)

    def time_call(self, name: str, func: Callable[[], Any]) -> Tuple[Any, float]:
        """Time a callable and record its latency and success/failure in Locust stats."""
        t0 = time.perf_counter()
        try:
            result = func()
            latency_ms = (time.perf_counter() - t0) * 1000.0
            self.sample.fire(name=name, latency_ms=latency_ms, success=True, error=None)
            return result, latency_ms
        except Exception as e:
            latency_ms = (time.perf_counter() - t0) * 1000.0
            self.sample.fire(name=name, latency_ms=latency_ms, success=False, error=str(e))
            raise

    def snapshot_total(self) -> Dict[str, Any]:
        """Return aggregate Locust metrics (avg, p50, p95, success rate)."""
        s = self.env.stats.total
        try:
            p50 = s.get_current_response_time_percentile(0.50) or 0.0
            p95 = s.get_current_response_time_percentile(0.95) or 0.0
        except AttributeError:
            p50 = s.get_response_time_percentile(0.50) or 0.0
            p95 = s.get_response_time_percentile(0.95) or 0.0

        total, fails = s.num_requests, s.num_failures
        success_rate = ((total - fails) / total * 100.0) if total else 0.0

        return {
            "ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()),
            "total_requests": total,
            "failures": fails,
            "success_rate_pct": round(success_rate, 2),
            "avg_latency_ms": round(getattr(s, "avg_response_time", 0.0), 2),
            "p50_latency_ms": round(p50, 2),
            "p95_latency_ms": round(p95, 2),
        }


class RAIGatewayClient:
    """SSRAI client wrapped with retries, circuit breaker, and Locust metrics."""

    def __init__(
        self,
        config_file: str,
        profile: Optional[str] = None,
        *,
        max_retries: int = 3,
        backoff_base_seconds: float = 0.5,
        backoff_max_seconds: float = 10.0,
        max_total_retry_seconds: float = 30.0,
        breaker_fail_threshold: int = 10,
        breaker_half_open_after: float = 30.0,
        events_log: str = "logs/rai_client_events.jsonl",
        metrics_log: str = "logs/locust_metrics.jsonl",
        request_type: str = "SSRAI",
        metrics_request_name: Optional[str] = None,
    ):
        """Initialize SSRAI client, breaker, metrics, and logging."""
        self.cli = SSRAIClient(config_file=config_file, profile=profile)
        if getattr(self.cli, "auth_type", None) == "pat" and not getattr(self.cli, "pat_token", None):
            env_pat = os.getenv("SSRAI_PAT_TOKEN")
            if env_pat:
                self.cli.pat_token = env_pat

        self.max_retries = max_retries
        self.backoff_base_seconds = backoff_base_seconds
        self.backoff_max_seconds = backoff_max_seconds
        self.max_total_retry_seconds = max_total_retry_seconds
        self.breaker = CircuitBreaker(breaker_fail_threshold, breaker_half_open_after)

        self.metrics = LocustMetrics(request_type=request_type)
        self._metrics_logger = setup_rot_logger("locust.metrics", metrics_log)
        self._events_logger = setup_rot_logger("rai.events", events_log)
        self._metrics_name = metrics_request_name or "TOTAL"

        atexit.register(self._write_metrics_snapshot_safe)

    def _log_event(self, event: str, **kv) -> None:
        """Log event details to JSONL file."""
        rec = {"ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()), "event": event, **kv}
        self._events_logger.info(json.dumps(rec, ensure_ascii=False))

    def _write_metrics_snapshot_safe(self) -> None:
        """Safely write aggregate metrics snapshot to JSONL file."""
        try:
            snap = self.get_locust_metrics_total()
            self._metrics_logger.info(json.dumps(snap, ensure_ascii=False))
        except Exception:
            pass

    def _backoff(self, attempt: int) -> float:
        """Return exponential backoff with jitter for retry delays."""
        return random.uniform(0, min(self.backoff_base_seconds * (2 ** attempt), self.backoff_max_seconds))

    def call_chat(
        self,
        messages: List[Dict[str, Any]],
        model: str,
        *,
        max_tokens: int = 512,
        temperature: float = 0.0,
        metrics_name: Optional[str] = None,
    ):
        """Call SSRAI chat API with retries, circuit breaker, and Locust metrics."""
        if not self.breaker.allow():
            self.metrics.sample.fire(
                name=(metrics_name or self._metrics_name), latency_ms=0.0, success=False, error="Circuit.Open"
            )
            self._log_event("breaker_open", model=model)
            self._write_metrics_snapshot_safe()
            raise RuntimeError("Circuit breaker OPEN")

        start_overall = time.perf_counter()
        last_exc: Optional[Exception] = None
        name_for_metrics = metrics_name or self._metrics_name

        for attempt in range(self.max_retries + 1):
            self._log_event("attempt_start", attempt=attempt + 1, model=model)

            def _do_call():
                return self.cli.chat.create(
                    model=model,
                    messages=messages,
                    max_tokens=max_tokens,
                    temperature=temperature,
                )

            try:
                resp, latency_ms = self.metrics.time_call(name_for_metrics, _do_call)
                self.breaker.on_success()
                self._log_event("attempt_end", status="success", latency_ms=round(latency_ms, 2), model=model)
                self._write_metrics_snapshot_safe()
                return resp
            except Exception as e:
                self.breaker.on_failure()
                self._log_event("attempt_end", status="fail", error=str(e), model=model)
                self._write_metrics_snapshot_safe()
                last_exc = e
                elapsed = time.perf_counter() - start_overall
                if attempt >= self.max_retries or elapsed >= self.max_total_retry_seconds:
                    break
                time.sleep(self._backoff(attempt))

        raise RuntimeError(f"RAI call failed after retries: {last_exc}")

    def get_locust_metrics_total(self) -> Dict[str, Any]:
        """Return latest Locust total metrics snapshot."""
        return self.metrics.snapshot_total()


if __name__ == "__main__":
    try:
        client = RAIGatewayClient(
            config_file="rai_config.yaml",
            profile="WITH_GUARDRAIL",
            max_retries=3,
            backoff_base_seconds=0.5,
            backoff_max_seconds=5.0,
            max_total_retry_seconds=20.0,
            breaker_fail_threshold=5,
            breaker_half_open_after=15.0,
            events_log="logs/rai_client_events.jsonl",
            metrics_log="logs/locust_metrics.jsonl",
            request_type="SSRAI",
            metrics_request_name="TOTAL",
        )

        resp = client.call_chat(
            messages=[{"role": "user", "content": "Hello!"}],
            model="rai-gpt-mini",
            max_tokens=64,
            temperature=0.2,
        )
        print("Response:", resp)

    except Exception as exc:
        print("Error:", exc)

    finally:
        print("Totals:", client.get_locust_metrics_total())
