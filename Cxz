package com.bofa.sst.batch.core.impl;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDateTime;
import java.util.*;               // for Set, HashSet, List, etc.

import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.annotation.BeforeStep;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import lombok.extern.log4j.Log4j2;

@Component
@Log4j2
public class CustaggProcessor 
    implements ItemProcessor<CustaggRecordsDTO, CustaggProcessedRecordsDTO> {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private Map<String, String> entityMap;

    // ─────────────── NEW: de-duplication set ─────────────── 
    /** Keeps track of prod|ent|acct that we've already processed in this step */
    private Set<String> seenRecordKeys;
    // ────────────────────────────────────────────────────────

    /** Load entityMap and init dedup set once per step (i.e. per partition) */
    @BeforeStep
    public void beforeStep(StepExecution stepExecution) {
        entityMap = (Map<String, String>) 
            stepExecution
              .getJobExecution()
              .getExecutionContext()
              .get("entityMap");

        if (entityMap == null || entityMap.isEmpty()) {
            log.error("CustaggProcessor: Entity map is not available");
            throw new IllegalStateException("Entity map not initialized");
        }
        log.info("CustaggProcessor: Retrieved entity map with {} entries.", entityMap.size());

        // ─────────────── NEW: initialize de-duplication set ───────────────
        seenRecordKeys = new HashSet<>();
        // ───────────────────────────────────────────────────────────────────
    }

    @Override
    public CustaggProcessedRecordsDTO process(CustaggRecordsDTO item) throws Exception {
        String entityFromFile  = item.getEntity().trim();
        String accountNumber   = item.getAccountNumber();
        String productCode     = item.getProductCode().trim();

        // ─────────────── NEW: build dedup key & check ───────────────
        String dedupKey = productCode + "|" + entityFromFile + "|" + accountNumber;
        if (!seenRecordKeys.add(dedupKey)) {
            log.debug("Duplicate detected, skipping record: {}", dedupKey);
            return null;
        }
        // ───────────────────────────────────────────────────────────────

        log.info("CustaggProcessor: Processing record – Entity: {}, Account: {}, Product: {}",
                  entityFromFile, accountNumber, productCode);

        // existing entityMap lookup
        String mappedEntity = entityMap.get(entityFromFile);
        if (mappedEntity == null) {
            log.warn("CustaggProcessor: No mapping for entity {} – skipping", entityFromFile);
            return null;
        }

        // build the enriched DTO
        CustaggProcessedRecordsDTO enrichedRecord = new CustaggProcessedRecordsDTO();
        enrichedRecord.setProductCode(productCode);
        enrichedRecord.setNumEntity(entityFromFile);
        enrichedRecord.setMappedEntity(mappedEntity);
        enrichedRecord.setAccountNumber(accountNumber);

        // fetch schedule IDs
        List<String> scheduleIds =
            fetchScheduleIds(accountNumber, entityFromFile, productCode);
        enrichedRecord.setScheduleIds(scheduleIds);

        // fetch & update transfer execution IDs
        List<String> transferExecutionIds =
            fetchAndUpdateTransferExecutionIds(scheduleIds);
        enrichedRecord.setTransferExecutionIds(transferExecutionIds);

        // fetch & update transfer instruction IDs
        if (!scheduleIds.isEmpty()) {
            fetchAndUpdateTransferInstructionIds(scheduleIds);
            enrichedRecord.setTransferInstructionIds(scheduleIds);  
            // (or however you collect them)
        }

        log.info("CustaggProcessor: Enriched record: {}", enrichedRecord);
        return enrichedRecord;
    }

    // ... your existing fetchScheduleIds, fetchAndUpdateTransferExecutionIds, etc.
}
