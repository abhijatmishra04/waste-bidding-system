package com.bofa.sst.batch.core.tasklet;

import lombok.extern.log4j.Log4j2;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;
import org.springframework.batch.core.configuration.annotation.StepScope;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

/**
 * 1) Confirms today’s REFER-DATA / REFER-ENTY files exist in the input directory<br>
 * 2) Creates lock files using FileUtils<br>
 * 3) Parses the refer-entry file into a Map&lt;NumEntity, AlphaEntity&gt;<br>
 * 4) Pushes the map + meta-data back into ExecutionContext for downstream steps
 */
@Log4j2
@Component
@StepScope        // <-- ensures proxy & correct step scope
public class CustaggFileValidationTasklet
        implements Tasklet, StepExecutionListener {

    private StepExecution stepExecution;   // set in beforeStep()

    // ───────────────────────────── lifecycle ─────────────────────────────
    @Override
    public void beforeStep(StepExecution stepExecution) {
        this.stepExecution = stepExecution;
    }

    @Override
    public ExitStatus afterStep(StepExecution stepExecution) {
        return ExitStatus.COMPLETED;
    }

    // ───────────────────────────── main work ─────────────────────────────
    @Override
    public RepeatStatus execute(StepContribution contribution,
                                ChunkContext chunkContext) throws Exception {

        ExecutionContext ctx = stepExecution.getJobExecution().getExecutionContext();

        // Grab values that a previous step already placed in the context
        String directoryPath        = ctx.getString(CustaggBatchConstants.DIRECTORY_PATH, null);
        String filePrefixReferData  = ctx.getString(CustaggBatchConstants.FILE_PREFIX_REFERDATA, null);
        String filePrefixReferEnty  = ctx.getString(CustaggBatchConstants.FILE_PREFIX_REFERENTY, null);

        if (directoryPath == null || filePrefixReferData == null || filePrefixReferEnty == null) {
            contribution.setExitStatus(ExitStatus.FAILED);
            throw new IllegalStateException(
                    "Mandatory values missing in ExecutionContext. "
                  + "Expected keys: DIRECTORY_PATH, FILE_PREFIX_REFERDATA, FILE_PREFIX_REFERENTY");
        }

        log.info("FileValidator – directoryPath='{}', referDataPrefix='{}', referEntyPrefix='{}'",
                 directoryPath, filePrefixReferData, filePrefixReferEnty);

        // 1️⃣  Locate today’s trigger files
        String referDataPath = FileUtils.findTodaysFiles(
                directoryPath, filePrefixReferData, CustaggBatchConstants.INPUT_FILE_EXTENSION);

        String referEntyPath = FileUtils.findTodaysFiles(
                directoryPath, filePrefixReferEnty, CustaggBatchConstants.INPUT_FILE_EXTENSION);

        if (referDataPath == null || referEntyPath == null) {
            contribution.setExitStatus(ExitStatus.FAILED);
            throw new java.io.FileNotFoundException(
                    "Could not find today’s files in directory " + directoryPath);
        }

        // 2️⃣  Lock the files so nobody else processes them
        FileUtils.lockFile(directoryPath, filePrefixReferData, CustaggBatchConstants.INPUT_FILE_EXTENSION);
        FileUtils.lockFile(directoryPath, filePrefixReferEnty, CustaggBatchConstants.INPUT_FILE_EXTENSION);
        log.info("Trigger files locked successfully");

        // 3️⃣  Parse REFER-ENTY fixed-width file → entityMap
        Map<String, String> entityMap = new HashMap<>();

        try (BufferedReader br = new BufferedReader(
                new FileReader(referEntyPath, StandardCharsets.US_ASCII))) {

            String line;
            int lineNumber = 0;

            while ((line = br.readLine()) != null) {
                lineNumber++;

                if (line.length() < 8) {
                    log.debug("Skipping short line {}: '{}'", lineNumber, line);
                    continue;
                }
                String alphaEntity = line.substring(0, 4).trim();
                String numEntity   = line.substring(4, 8).trim();

                if (alphaEntity.isEmpty() || numEntity.isEmpty()) {
                    log.debug("Skipping missing-value line {} '{}'", lineNumber, line);
                    continue;
                }
                entityMap.put(numEntity, alphaEntity);
            }
        }

        // 4️⃣  Stash everything back into the ExecutionContext
        ctx.put("entityMap",            entityMap);          // downstream reader/processor will use
        ctx.put("filePrefixReferData",  filePrefixReferData); // optional: keep for later steps
        ctx.put("filePrefixReferEnty",  filePrefixReferEnty);

        log.info("Validation complete – dataFile='{}', entyFile='{}', mappings={}",
                 new File(referDataPath).getName(),
                 new File(referEntyPath).getName(),
                 entityMap.size());

        return RepeatStatus.FINISHED;
    }
}
