#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, re, io, json, time, base64, shutil, argparse, logging, tempfile
from typing import List, Optional, OrderedDict as TOrderedDict
from collections import OrderedDict

# PDF → PNG
try:
    import fitz  # PyMuPDF
    _HAVE_FITZ = True
except Exception:
    _HAVE_FITZ = False
import pdfplumber

# Pydantic v2
from pydantic import BaseModel, Field, field_validator

# LangChain core
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from langchain_core.runnables import RunnableLambda

# RAI SDK
from ssrai import SSRAIClient


class KV(BaseModel):
    key: str = Field(...); value: str = Field(...); page: int = Field(..., ge=1)
    confidence: float = Field(..., ge=0, le=1)
    @field_validator("key")
    @classmethod
    def _strip_key(cls, v: str) -> str: return v.strip()

class ExtractedDoc(BaseModel):
    items: List[KV] = Field(default_factory=list)


def setup_logger(level: str, log_file: Optional[str]) -> logging.Logger:
    lvl = getattr(logging, level.upper(), logging.INFO)
    logger = logging.getLogger("pdf2json"); logger.setLevel(lvl); logger.handlers.clear()
    fmt = logging.Formatter("%(asctime)s | %(levelname)-8s | %(name)s | %(message)s", "%Y-%m-%d %H:%M:%S")
    ch = logging.StreamHandler(); ch.setLevel(lvl); ch.setFormatter(fmt); logger.addHandler(ch)
    if log_file:
        os.makedirs(os.path.dirname(log_file) or ".", exist_ok=True)
        fh = logging.FileHandler(log_file, encoding="utf-8"); fh.setLevel(lvl); fh.setFormatter(fmt); logger.addHandler(fh)
    if lvl > logging.DEBUG:
        logging.getLogger("urllib3.connectionpool").setLevel(logging.WARNING)
        logging.getLogger("ssrai").setLevel(logging.INFO)
        logging.getLogger("pdfplumber").setLevel(logging.WARNING)
    return logger


class PDF2JSON:
    def __init__(self, cfg: str, model: str, *, temperature=0.0, max_tokens=1300,
                 allowed_keys: Optional[List[str]]=None, max_pages=10, dpi=200,
                 dump_images: Optional[str]=None, keep_images=False, logger: Optional[logging.Logger]=None):
        self.cli = SSRAIClient(config_file=cfg)
        self.model = model
        self.temperature = temperature
        self.max_tokens = max_tokens
        self.allowed_keys = allowed_keys or []
        self.max_pages = max_pages
        self.dpi = dpi
        self.dump_images = dump_images
        self.keep_images = keep_images
        self.log = logger or logging.getLogger("pdf2json")

        # prompt
        self.parser = PydanticOutputParser(pydantic_object=ExtractedDoc)
        allowed_keys_block = ("Only output keys from this list:\n- " + "\n- ".join(self.allowed_keys) + "\n"
                              if self.allowed_keys else "Output any clearly labeled field names as keys.\n")
        prompt_t = r"""
You are a precise information-extraction engine.
Given attached INVOICE PAGE IMAGES (PNG), extract explicit **key-value** pairs.

Rules:
- {{ allowed_keys_block }}
- Keep values verbatim; normalize whitespace only.
- If a field repeats across pages, still return it (we will dedupe later).
- If nothing certain is present, return {"items": []}.
- Estimate confidence between 0 and 1.
- Return **ONLY** valid JSON following the schema.

{{format_instructions}}
""".strip()
        strict_suffix = "\n\nREMINDER: Output JSON ONLY. No markdown, no prose, no comments."
        self.prompt = PromptTemplate(template=prompt_t, template_format="jinja2",
                                     input_variables=["allowed_keys_block"],
                                     partial_variables={"format_instructions": self.parser.get_format_instructions()})
        self.prompt_strict = PromptTemplate(template=prompt_t+strict_suffix, template_format="jinja2",
                                     input_variables=["allowed_keys_block"],
                                     partial_variables={"format_instructions": self.parser.get_format_instructions()})
        self.to_text = RunnableLambda(lambda p: p.to_string() if hasattr(p, "to_string") else str(p))

        # sanitizer
        def _sanitize(text: str) -> str:
            try: json.loads(text); return text
            except Exception: pass
            m = re.search(r"```json\s*(\{.*?\})\s*```", text, flags=re.DOTALL|re.IGNORECASE)
            if m: return m.group(1)
            s,e = text.find("{"), text.rfind("}")
            return text[s:e+1] if (s!=-1 and e!=-1 and e>s) else text
        self.sanitize = RunnableLambda(_sanitize)

    # ---------- PDF → PNG paths ----------
    def _pdf_to_png_paths(self, pdf_path: str) -> List[str]:
        if self.dump_images: out_dir, temp_dir = self.dump_images, None; os.makedirs(out_dir, exist_ok=True)
        else: temp_dir = tempfile.mkdtemp(prefix="pdfpng_"); out_dir = temp_dir
        self._temp_render_dir = None if self.keep_images or self.dump_images else temp_dir

        paths: List[str] = []
        t0 = time.perf_counter()
        if _HAVE_FITZ:
            self.log.info("PyMuPDF render @%ddpi (max_pages=%d)", self.dpi, self.max_pages)
            doc = fitz.open(pdf_path); total = min(doc.page_count, self.max_pages)
            self.log.info("PDF pages=%d; rendering %d", doc.page_count, total)
            for i in range(total):
                page = doc.load_page(i); mat = fitz.Matrix(self.dpi/72, self.dpi/72)
                pix = page.get_pixmap(matrix=mat, alpha=False)
                out = os.path.join(out_dir, f"page_{i+1:03d}.png"); pix.save(out); paths.append(out)
                self.log.debug("Rendered p%d: %dx%d -> %s", i+1, pix.width, pix.height, out)
            doc.close()
        else:
            self.log.info("pdfplumber render @%ddpi (max_pages=%d)", self.dpi, self.max_pages)
            with pdfplumber.open(pdf_path) as pdf:
                total = min(len(pdf.pages), self.max_pages)
                for i in range(total):
                    img = pdf.pages[i].to_image(resolution=self.dpi).original
                    out = os.path.join(out_dir, f"page_{i+1:03d}.png"); img.save(out, format="PNG"); paths.append(out)
                    self.log.debug("Rendered p%d -> %s", i+1, out)
        dt = (time.perf_counter()-t0)*1000
        self.log.info("Rendered %d PNG(s) in %.1f ms (%.1f MB).", len(paths), dt,
                      sum(os.path.getsize(p) for p in paths)/(1024*1024))
        return paths

    # ---------- build content in 3 possible shapes ----------
    @staticmethod
    def _as_dataurl(b64: str) -> dict:
        return {"type": "input_image", "image_url": {"url": f"data:image/png;base64,{b64}"}}
    @staticmethod
    def _as_base64(b64: str) -> dict:
        return {"type": "input_image", "image_base64": b64}
    @staticmethod
    def _as_generic(b64: str) -> dict:
        return {"type": "image", "mime_type": "image/png", "data": b64}

    def _paths_to_payloads(self, paths: List[str], variant: str) -> List[dict]:
        parts = []
        for p in paths:
            with open(p, "rb") as f: b64 = base64.b64encode(f.read()).decode("ascii")
            if variant == "dataurl": parts.append(self._as_dataurl(b64))
            elif variant == "base64": parts.append(self._as_base64(b64))
            else: parts.append(self._as_generic(b64))
        return parts

    # ---------- call with fallback formats ----------
    def _call_with_formats(self, prompt: str, paths: List[str]) -> str:
        formats = ["dataurl", "base64", "generic"]
        last_err = None
        for fmt in formats:
            content = self._paths_to_payloads(paths, fmt)
            self.log.info("Calling model with image format: %s", fmt)
            messages = [
                {"role": "system",
                 "content": "You are a precise extraction engine. Reply ONLY with JSON matching the required schema."},
                {"role": "user", "content": [{"type": "text", "text": prompt}] + content},
            ]
            try:
                t0 = time.perf_counter()
                resp = self.cli.chat.create(model=self.model, messages=messages,
                                            max_tokens=self.max_tokens, temperature=self.temperature, n=1)
                dt = (time.perf_counter()-t0)*1000
                self.log.info("RAI chat.create ok in %.1f ms (format=%s)", dt, fmt)
                msg = resp["choices"][0]["message"]
                out = msg.get("content", "")
                if isinstance(out, list) and out and isinstance(out[0], dict):
                    out = out[0].get("text", "")
                return str(out)
            except Exception as e:
                last_err = e
                self.log.warning("Format '%s' failed: %s", fmt, e)
        raise last_err

    @staticmethod
    def _merge_items(items: List[KV]) -> List[KV]:
        by_key: dict[str, KV] = {}
        for it in items:
            norm = re.sub(r"[^a-z0-9]+", " ", it.key.lower()).strip()
            if norm not in by_key: by_key[norm] = it
            else:
                keep = by_key[norm]
                if len(it.value) > len(keep.value) or it.confidence > keep.confidence: by_key[norm] = it
        return [by_key[k] for k in OrderedDict.fromkeys(by_key.keys())]

    def run(self, pdf_path: str) -> TOrderedDict[str, str]:
        self.log.info("Start ingest")
        pngs = self._pdf_to_png_paths(pdf_path)
        if not pngs: raise RuntimeError("No PNGs produced from PDF.")

        prompt = (self.prompt | RunnableLambda(lambda x: x)).invoke({"allowed_keys_block": (
            "Only output keys from this list:\n- " + "\n- ".join(self.allowed_keys) + "\n"
            if self.allowed_keys else "Output any clearly labeled field names as keys.\n"
        )})
        # ensure string (PromptValue safety)
        prompt = prompt.to_string() if hasattr(prompt, "to_string") else str(prompt)

        try:
            raw = self._call_with_formats(prompt, pngs)
            payload = self.sanitize.invoke(raw)
            doc = self.parser.parse(payload)
        except Exception as e:
            self.log.warning("Parse failed once (%s). Retrying with strict prompt...", e)
            prompt2 = (self.prompt_strict | RunnableLambda(lambda x: x)).invoke({"allowed_keys_block": (
                "Only output keys from this list:\n- " + "\n- ".join(self.allowed_keys) + "\n"
                if self.allowed_keys else "Output any clearly labeled field names as keys.\n"
            )})
            prompt2 = prompt2.to_string() if hasattr(prompt2, "to_string") else str(prompt2)
            raw = self._call_with_formats(prompt2, pngs)
            payload = self.sanitize.invoke(raw)
            doc = self.parser.parse(payload)

        items = doc.items or []
        self.log.info("Model returned %d item(s).", len(items))
        merged = self._merge_items(items)
        self.log.info("After merge: %d unique key(s).", len(merged))
        for it in merged:
            self.log.debug("KV: %r = %r (p%d, conf=%.2f)", it.key, it.value, it.page, it.confidence)

        # cleanup temp
        if getattr(self, "_temp_render_dir", None) and not self.keep_images:
            shutil.rmtree(self._temp_render_dir, ignore_errors=True)
            self.log.debug("Deleted temp dir %s", self._temp_render_dir)

        return OrderedDict((it.key, it.value) for it in merged)


def default_out(pdf_path: str) -> str:
    root, _ = os.path.splitext(pdf_path); return f"{root}.kv.json"


def main():
    ap = argparse.ArgumentParser(description="PDF → PNG → LLM KV extractor (images only, with robust image payload fallback)")
    ap.add_argument("--cfg", required=True); ap.add_argument("--model", required=True)
    ap.add_argument("--pdf", required=True); ap.add_argument("--out", default=None)
    ap.add_argument("--allowed_keys", default=None)
    ap.add_argument("--max-pages", type=int, default=10); ap.add_argument("--dpi", type=int, default=200)
    ap.add_argument("--max-tokens", type=int, default=1300); ap.add_argument("--temperature", type=float, default=0.0)
    ap.add_argument("--dump-images", default=None); ap.add_argument("--keep-images", action="store_true")
    ap.add_argument("--log-level", default="INFO", choices=["DEBUG","INFO","WARNING","ERROR"])
    ap.add_argument("--log-file", default=None)
    args = ap.parse_args()

    logger = setup_logger(args.log_level, args.log_file)

    allowed = [s.strip() for s in args.allowed_keys.split(",")] if args.allowed_keys else None
    agent = PDF2JSON(cfg=args.cfg, model=args.model, temperature=args.temperature, max_tokens=args.max_tokens,
                     allowed_keys=allowed, max_pages=args.max_pages, dpi=args.dpi,
                     dump_images=args.dump_images, keep_images=args.keep_images, logger=logger)

    kv = agent.run(args.pdf)
    out_path = args.out or default_out(args.pdf)
    os.makedirs(os.path.dirname(out_path) or ".", exist_ok=True)
    with open(out_path, "w", encoding="utf-8") as f: json.dump(kv, f, indent=2, ensure_ascii=False)
    logger.info("Wrote key–value JSON to: %s", out_path)

if __name__ == "__main__":
    main()
