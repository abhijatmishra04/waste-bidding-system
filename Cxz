
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
RAI Gateway client with Locust total metrics only
- SSRAI SDK untouched (no gevent monkey-patching)
- Retries + exponential backoff + circuit breaker
- Locust custom-event drives total metrics (avg/p50/p95/success rate/RPS)
- Rotating JSONL snapshots: logs/locust_metrics.jsonl
"""

import os
import time
import json
import random
import logging
import threading
from logging.handlers import RotatingFileHandler
from typing import Any, Dict, List, Optional

# Locust without monkey patching
os.environ.setdefault("LOCUST_NO_MONKEY_PATCH", "1")
from locust.env import Environment
from locust.event import EventHook

# SSRAI SDK
from ssrai import SSRAIClient


# --------- logging ---------
def setup_rot_logger(name: str, path: str) -> logging.Logger:
    lg = logging.getLogger(name)
    lg.setLevel(logging.INFO)
    lg.propagate = False
    if not lg.handlers:
        os.makedirs(os.path.dirname(os.path.abspath(path)), exist_ok=True)
        fh = RotatingFileHandler(path, maxBytes=10 * 1024 * 1024, backupCount=3)
        fh.setFormatter(logging.Formatter("%(message)s"))
        lg.addHandler(fh)
    return lg


# --------- circuit breaker ---------
class CircuitBreaker:
    def __init__(self, fail_threshold: int = 10, half_open_after: float = 30.0):
        self.state = "CLOSED"
        self.fail_count = 0
        self.opened_at = 0.0
        self.fail_threshold = fail_threshold
        self.half_open_after = half_open_after
        self._lock = threading.Lock()

    def allow(self) -> bool:
        with self._lock:
            if self.state == "OPEN" and (time.time() - self.opened_at) > self.half_open_after:
                self.state = "HALF_OPEN"
            return self.state != "OPEN"

    def on_success(self):
        with self._lock:
            self.fail_count = 0
            self.state = "CLOSED"

    def on_failure(self):
        with self._lock:
            self.fail_count += 1
            if self.fail_count >= self.fail_threshold and self.state != "OPEN":
                self.state = "OPEN"
                self.opened_at = time.time()

    def get_state(self) -> str:
        with self._lock:
            return self.state


# --------- locust total metrics via custom event ---------
class LocustTotals:
    """
    Single-process Locust Environment; custom EventHook forwards to env.events.request.
    Only total metrics are exposed.
    """

    def __init__(self):
        self.env = Environment(user_classes=[])
        self.env.create_local_runner()  # wires stats + request event
        self.event = EventHook()
        self._attach()

    def _attach(self):
        def _on_event(latency_ms: float, success: bool, error: Optional[str]):
            if success:
                try:
                    self.env.events.request.fire(
                        request_type="SSRAI",
                        name="TOTAL",
                        response_time=float(latency_ms),
                        response_length=0,
                        exception=None,
                    )
                except TypeError:
                    self.env.events.request.fire(
                        request_type="SSRAI",
                        name="TOTAL",
                        response_time=float(latency_ms),
                        exception=None,
                    )
            else:
                err = RuntimeError(error or "error")
                try:
                    self.env.events.request.fire(
                        request_type="SSRAI",
                        name="TOTAL",
                        response_time=float(latency_ms),
                        response_length=0,
                        exception=err,
                    )
                except TypeError:
                    self.env.events.request.fire(
                        request_type="SSRAI",
                        name="TOTAL",
                        response_time=float(latency_ms),
                        exception=err,
                    )
        self.event.add_listener(_on_event)

    def fire(self, latency_ms: float, success: bool, error: Optional[str] = None):
        self.event.fire(latency_ms=latency_ms, success=success, error=error)

    def snapshot_total(self) -> Dict[str, Any]:
        s = self.env.stats.total
        return {
            "ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()),
            "total_requests": s.num_requests,
            "failures": s.num_failures,
            "success_rate_pct": round(((s.num_requests - s.num_failures) / s.num_requests * 100) if s.num_requests else 0.0, 2),
            "avg_latency_ms": round(getattr(s, "avg_response_time", 0.0), 2),
            "p50_latency_ms": round(s.get_response_time_percentile(0.50) or 0.0, 2),
            "p95_latency_ms": round(s.get_response_time_percentile(0.95) or 0.0, 2),
            "current_rps": round(getattr(s, "current_rps", 0.0), 2),
        }


# --------- RAI gateway client ---------
class RAIGatewayClient:
    """
    SSRAI wrapper with retries + circuit breaker.
    Sends per-attempt results to LocustTotals.
    Logs client events; can also log periodic totals to JSONL.
    """

    def __init__(
        self,
        config_file: str,
        profile: Optional[str] = None,
        *,
        max_retries: int = 3,
        backoff_base_seconds: float = 0.5,
        backoff_max_seconds: float = 10.0,
        max_total_retry_seconds: float = 30.0,
        breaker_fail_threshold: int = 10,
        breaker_half_open_after: float = 30.0,
        events_log: str = "logs/rai_client_events.jsonl",
        metrics_log: str = "logs/locust_metrics.jsonl",
        extra_fields: Optional[Dict[str, Any]] = None,
    ):
        self.cli = SSRAIClient(config_file=config_file, profile=profile)
        if getattr(self.cli, "auth_type", None) == "pat" and not getattr(self.cli, "pat_token", None):
            env_pat = os.getenv("SSRAI_PAT_TOKEN")
            if env_pat:
                self.cli.pat_token = env_pat

        self.max_retries = int(max_retries)
        self.backoff_base_seconds = float(backoff_base_seconds)
        self.backoff_max_seconds = float(backoff_max_seconds)
        self.max_total_retry_seconds = float(max_total_retry_seconds)
        self.breaker = CircuitBreaker(breaker_fail_threshold, breaker_half_open_after)

        self.metrics = LocustTotals()

        self._events_logger = setup_rot_logger("rai.events", events_log)
        self._metrics_logger = setup_rot_logger("locust.metrics", metrics_log)
        self._metrics_log_path = metrics_log
        self._extra = extra_fields or {}

    # event logging
    def _log(self, event: str, **kv):
        rec = {
            "ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()),
            "event": event,
            **self._extra,
            **kv,
        }
        self._events_logger.info(json.dumps(rec, ensure_ascii=False))

    # backoff
    def _backoff(self, attempt: int) -> float:
        base = self.backoff_base_seconds * (2 ** attempt)
        return random.uniform(0, min(base, self.backoff_max_seconds))

    # core call
    def call_chat(
        self,
        messages: List[Dict[str, Any]],
        model: str,
        *,
        max_tokens: int = 512,
        temperature: float = 0.0,
        guardrail_profile: Optional[str] = None,
    ) -> Dict[str, Any]:
        if not self.breaker.allow():
            self.metrics.fire(0.0, False, "Circuit.Open")
            self._log("breaker_open", model=model)
            raise RuntimeError("Circuit breaker OPEN")

        start_overall = time.perf_counter()
        last_exc: Optional[Exception] = None

        for attempt in range(self.max_retries + 1):
            t0 = time.perf_counter()
            self._log("attempt_start", attempt=attempt + 1, model=model)

            try:
                resp = self.cli.chat.create(
                    model=model,
                    messages=messages,
                    max_tokens=max_tokens,
                    temperature=temperature,
                    guardrail_profile=guardrail_profile,
                )
                latency_ms = (time.perf_counter() - t0) * 1000.0
                self.breaker.on_success()
                self.metrics.fire(latency_ms, True)
                self._log("attempt_end", status="success", latency_ms=round(latency_ms, 2), model=model)
                return resp

            except Exception as e:
                last_exc = e
                latency_ms = (time.perf_counter() - t0) * 1000.0
                self.breaker.on_failure()
                self.metrics.fire(latency_ms, False, str(e))
                self._log("attempt_end", status="failure", error=str(e), latency_ms=round(latency_ms, 2), model=model)

                elapsed = time.perf_counter() - start_overall
                final = (attempt >= self.max_retries) or (elapsed >= self.max_total_retry_seconds)
                if final:
                    break
                time.sleep(self._backoff(attempt))

        raise RuntimeError(f"RAI call failed after retries: {last_exc}")

    # total metrics (dict)
    def get_locust_metrics_total(self) -> Dict[str, Any]:
        return self.metrics.snapshot_total()

    # background JSONL snapshotter
    def start_metrics_logger(self, interval_sec: int = 5) -> threading.Thread:
        def _loop():
            while True:
                snap = self.get_locust_metrics_total()
                self._metrics_logger.info(json.dumps(snap, ensure_ascii=False))
                time.sleep(interval_sec)

        th = threading.Thread(target=_loop, name="LocustTotalsLogger", daemon=True)
        th.start()
        return th
