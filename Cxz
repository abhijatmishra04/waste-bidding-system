package com.bofa.sst.batch.core.impl;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.*;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.*;

import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementSetter;

/**
 * 100 % line + branch coverage for {@link CustaggWriter}.
 * Uses ONLY: junit-4.13.x, mockito-inline-3.8.0, spring-batch-core (already on your classpath).
 */
@RunWith(MockitoJUnitRunner.class)
public class CustaggWriterTest {

    /* ------------------------------------------------------------------ *
     *  collaborators
     * ------------------------------------------------------------------ */
    @Mock  private NamedParameterJdbcTemplate npJdbc;
    @Mock  private JdbcTemplate              jdbc;

    private CustaggWriter writer;        // unit under test
    private StepExecution step;          // fake step context

    @Rule public ExpectedException thrown = ExpectedException.none();

    @Before
    public void init() {
        writer = new CustaggWriter(npJdbc, jdbc);

        JobExecution je = new JobExecution(1L);
        step            = new StepExecution("custaggStep", je);
        step.setCommitCount(100);
        writer.captureStepExecution(step);       // mimics @BeforeStep
    }

    /* ------------------------------------------------------------------ *
     *  1. Happy-path : every table fetched & updated
     * ------------------------------------------------------------------ */
    @Test
    public void should_fetchAndUpdateAllThreeTables_andPushMetrics() throws Exception {

        // ---- stub three SELECTs ---------------------------------------------------
        AtomicInteger sel = new AtomicInteger();
        when(npJdbc.queryForList(anyString(), any(Map.class), eq(String.class)))
            .thenAnswer(inv -> switch (sel.getAndIncrement()) {
                case 0  -> List.of("SCH1", "SCH2");             // schedule IDs
                case 1  -> List.of("EX1");                       // execution IDs
                default -> List.of("IN1", "IN2");                // instruction IDs
            });

        // ---- stub three UPDATE slices --------------------------------------------
        when(jdbc.batchUpdate(anyString(),
                              any(List.class),
                              anyInt(),
                              any(PreparedStatementSetter.class)))
            .thenAnswer(inv -> {
                int n   = ((List<?>) inv.getArgument(1)).size(); // rows in this slice
                int[][] rc = new int[n][1];
                Arrays.stream(rc).forEach(r -> r[0] = 1);        // 1 row affected each
                return rc;
            });

        // ---- execute --------------------------------------------------------------
        writer.write(List.of(
                dto("ACC1", "E01", "P01"),
                dto("ACC2", "E01", "P01")
        ));
        writer.flushMetrics();                                   // mimics @AfterStep

        // ---- verify JDBC usage ----------------------------------------------------
        verify(npJdbc, times(3)).queryForList(anyString(), any(Map.class), eq(String.class));
        verify(jdbc,   times(3)).batchUpdate(anyString(), any(List.class),
                                             anyInt(), any(PreparedStatementSetter.class));

        // ---- metrics pushed into ExecutionContext ---------------------------------
        ExecutionContext ec = step.getExecutionContext();
        assertThat(ec.getLong("schedFetched"), is(2L));
        assertThat(ec.getLong("execFetched") , is(1L));
        assertThat(ec.getLong("instrFetched"), is(2L));
        assertThat(ec.getLong("schedUpdated"), is(2L));
        assertThat(ec.getLong("execUpdated") , is(1L));
        assertThat(ec.getLong("instrUpdated"), is(2L));
    }

    /* ------------------------------------------------------------------ *
     *  2. Empty chunk → early return, zero JDBC calls
     * ------------------------------------------------------------------ */
    @Test
    public void write_withEmptyChunk_doesNothing() throws Exception {
        writer.write(Collections.emptyList());

        verifyNoInteractions(npJdbc, jdbc);
        assertTrue(step.getExecutionContext().isEmpty());
    }

    /* ------------------------------------------------------------------ *
     *  3. No schedule IDs → fetch done, update skipped
     * ------------------------------------------------------------------ */
    @Test
    public void write_whenNoScheduleIds_skipsRest() throws Exception {
        when(npJdbc.queryForList(anyString(), any(Map.class), eq(String.class)))
            .thenReturn(Collections.emptyList());               // first SELECT → 0 rows

        writer.write(List.of(dto("ACC1", "E01", "P01")));

        verify(npJdbc, times(1)).queryForList(anyString(), any(Map.class), eq(String.class));
        verifyNoInteractions(jdbc);                             // no UPDATEs
        assertEquals(0L, step.getExecutionContext().getLong("schedUpdated", 0L));
    }

    /* ------------------------------------------------------------------ *
     *  4. Exception during SELECT → partial metrics & re-thrown error
     * ------------------------------------------------------------------ */
    @Test
    public void write_whenSelectFails_pushesPartialMetrics_andRethrows() throws Exception {
        when(npJdbc.queryForList(anyString(), any(Map.class), eq(String.class)))
            .thenThrow(new DataAccessException("boom") { private static final long serialVersionUID = 1L; });

        thrown.expect(DataAccessException.class);

        try {
            writer.write(List.of(dto("ACC1", "E01", "P01")));
        } finally {
            assertTrue(step.getExecutionContext().containsKey("schedFetched"));
            assertEquals(0L, step.getExecutionContext().getLong("schedUpdated")); // never reached
        }
    }

    /* ------------------------------------------------------------------ *
     *  5. Private helper fetchPaged() – >990 literals branch
     * ------------------------------------------------------------------ */
    @Test
    public void fetchPaged_withHugeSet_splitsIntoSlices() throws Exception {
        List<String> huge = new ArrayList<>();
        for (int i = 0; i < 1_001; i++) huge.add("ID" + i);     // triggers paging

        when(npJdbc.queryForList(anyString(), any(Map.class), eq(String.class)))
            .thenAnswer(inv -> new ArrayList<>(((Map<?, ?>) inv.getArgument(1))
                                               .values()
                                               .iterator()
                                               .next()));       // echo back slice

        Method m = CustaggWriter.class.getDeclaredMethod("fetchPaged",
                String.class, Map.class, List.class);
        m.setAccessible(true);

        @SuppressWarnings("unchecked")
        List<String> result = (List<String>) m.invoke(writer,
                "dummySql",
                Map.of("accNos", huge),
                List.of("accNos"));

        assertEquals(1_001, result.size());
        verify(npJdbc, atLeast(2)).queryForList(anyString(), any(Map.class), eq(String.class));
    }

    /* ------------------------------------------------------------------ *
     *  6. Private helper batchUpdatePaged() – both param-count variants
     * ------------------------------------------------------------------ */
    @Test
    public void batchUpdatePaged_affectsAllRows_forBothVariants() throws Exception {
        List<String> ids = new ArrayList<>();
        for (int i = 0; i < 1_100; i++) ids.add("ID" + i);      // 2 slices

        when(jdbc.batchUpdate(anyString(),
                              any(List.class),
                              anyInt(),
                              any(PreparedStatementSetter.class)))
            .thenAnswer(inv -> {
                int n = ((List<?>) inv.getArgument(1)).size();
                int[][] rc = new int[n][1];
                Arrays.stream(rc).forEach(r -> r[0] = 1);
                return rc;
            });

        Method m = CustaggWriter.class.getDeclaredMethod("batchUpdatePaged",
                String.class, Timestamp.class, List.class, int.class);
        m.setAccessible(true);

        int updated3 = (int) m.invoke(writer, "SQL",
                Timestamp.from(Instant.now()), ids, 3);
        int updated2 = (int) m.invoke(writer, "SQL",
                Timestamp.from(Instant.now()), ids, 2);

        assertEquals(1_100, updated3);
        assertEquals(1_100, updated2);
        verify(jdbc, times(4))        // 2 slices × 2 invocations
              .batchUpdate(anyString(), any(List.class), anyInt(), any(PreparedStatementSetter.class));
    }

    /* ------------------------------------------------------------------ *
     *  helper – quick DTO factory
     * ------------------------------------------------------------------ */
    private static CustaggProcessedRecordsDTO dto(String acc, String ent, String prod) {
        CustaggProcessedRecordsDTO d = new CustaggProcessedRecordsDTO();
        d.setAccountNumber(acc);
        d.setNumEntity(ent);
        d.setProductCode(prod);
        return d;
    }
}
