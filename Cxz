#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
SSRAI client â†’ writes per-call latency feed for Locust worker.
Safe (no gevent patching).
"""

import os, time, json, random, logging, threading
from logging.handlers import RotatingFileHandler
from typing import Any, Callable, Dict, List, Optional
from ssrai import SSRAIClient

# ---------- logger ----------
def _rot_logger(name, path):
    lg = logging.getLogger(name)
    lg.setLevel(logging.INFO)
    lg.propagate = False
    if not lg.handlers:
        os.makedirs(os.path.dirname(os.path.abspath(path)), exist_ok=True)
        fh = RotatingFileHandler(path, maxBytes=10*1024*1024, backupCount=3)
        fh.setFormatter(logging.Formatter("%(message)s"))
        lg.addHandler(fh)
    return lg

# ---------- circuit breaker ----------
class CircuitBreaker:
    def __init__(self, fail_threshold=10, half_open_after=30.0):
        self.state, self.fail_count, self.opened_at = "CLOSED", 0, 0.0
        self.fail_threshold, self.half_open_after = fail_threshold, half_open_after
        self._lock = threading.Lock()
    def allow(self):
        with self._lock:
            if self.state=="OPEN" and (time.time()-self.opened_at)>self.half_open_after:
                self.state="HALF_OPEN"
            return self.state!="OPEN"
    def on_success(self):
        with self._lock: self.fail_count, self.state = 0, "CLOSED"
    def on_failure(self):
        with self._lock:
            self.fail_count += 1
            if self.fail_count>=self.fail_threshold:
                self.state, self.opened_at = "OPEN", time.time()
    def get_state(self): 
        with self._lock: return self.state

# ---------- main client ----------
class RAIGatewayClient:
    def __init__(self, config_file:str, profile:str=None, *,
                 max_retries=3, backoff_base_seconds=0.5,
                 backoff_max_seconds=10.0, max_total_retry_seconds=30.0,
                 breaker_fail_threshold=10, breaker_half_open_after=30.0,
                 feed_file="logs/latency_feed.jsonl",
                 events_log="logs/rai_client_events.jsonl",
                 extra_fields:Optional[Dict[str,Any]]=None,
                 on_failure:Optional[Callable[[Dict[str,Any]],None]]=None):
        self.cli = SSRAIClient(config_file=config_file, profile=profile)
        if getattr(self.cli,"auth_type",None)=="pat" and not getattr(self.cli,"pat_token",None):
            env_pat=os.getenv("SSRAI_PAT_TOKEN")
            if env_pat: self.cli.pat_token=env_pat

        self.max_retries=max_retries; self.backoff_base_seconds=backoff_base_seconds
        self.backoff_max_seconds=backoff_max_seconds; self.max_total_retry_seconds=max_total_retry_seconds
        self._breaker=CircuitBreaker(breaker_fail_threshold,breaker_half_open_after)
        self._events=_rot_logger("rai.events",events_log)
        self._feed_path=os.path.abspath(feed_file)
        os.makedirs(os.path.dirname(self._feed_path),exist_ok=True)
        self._extra=extra_fields or {}; self.on_failure=on_failure
        self._lock=threading.Lock(); self._latencies=[]

    def _log(self, event, **kv):
        rec={"ts":time.strftime("%Y-%m-%dT%H:%M:%S",time.gmtime()),"event":event,**self._extra,**kv}
        self._events.info(json.dumps(rec,ensure_ascii=False))
    def _backoff(self,i): 
        return random.uniform(0,min(self.backoff_base_seconds*(2**i),self.backoff_max_seconds))
    def _feed(self, model, ok, latency, err=""):
        rec={"ts":time.strftime("%Y-%m-%dT%H:%M:%S",time.gmtime()),
             "model":model,"ok":ok,"latency_ms":int(round(latency)),"error":err}
        with open(self._feed_path,"a",encoding="utf-8") as f:
            f.write(json.dumps(rec,ensure_ascii=False)+"\n")

    def call_chat(self, messages:List[Dict[str,Any]], model:str, *,
                  max_tokens=512, temperature=0.0, guardrail_profile=None):
        if not self._breaker.allow():
            self._feed(model,False,0.0,"Circuit.Open")
            raise RuntimeError("Circuit breaker OPEN")
        start=time.perf_counter(); last=None
        for attempt in range(self.max_retries+1):
            t0=time.perf_counter(); self._log("attempt_start",attempt=attempt+1,model=model)
            try:
                resp=self.cli.chat.create(model=model,messages=messages,
                                          max_tokens=max_tokens,temperature=temperature,
                                          guardrail_profile=guardrail_profile)
                lat=(time.perf_counter()-t0)*1000
                self._breaker.on_success(); self._feed(model,True,lat)
                self._log("attempt_end",status="success",latency_ms=round(lat,2))
                return resp
            except Exception as e:
                last=e; lat=(time.perf_counter()-t0)*1000
                self._breaker.on_failure(); self._feed(model,False,lat,str(e))
                self._log("attempt_end",status="fail",error=str(e))
                if attempt>=self.max_retries or (time.perf_counter()-start)>=self.max_total_retry_seconds:
                    break
                time.sleep(self._backoff(attempt))
        raise last or RuntimeError("RAI call failed")

    @staticmethod
    def read_latest_locust_metrics(path="logs/locust_metrics.jsonl"):
        try:
            if not os.path.exists(path): return None
            with open(path,"rb") as f:
                f.seek(0,os.SEEK_END); buf=b""; pos=f.tell()
                while pos>0:
                    step=min(4096,pos); pos-=step; f.seek(pos)
                    chunk=f.read(step); buf=chunk+buf
                    if b"\n" in buf:
                        for line in reversed(buf.split(b"\n")):
                            if line.strip():
                                return json.loads(line.decode("utf-8"))
            return None
        except Exception: return None

    @classmethod
    def from_cfg(cls,cfg,*,profile=None,**kw):
        return cls(config_file=cfg,profile=profile,**kw)
