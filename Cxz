package com.bofa.sst.batch.core.impl;

import com.bofa.sst.batch.model.CustaggProcessedRecordsDTO;
import com.bofa.sst.batch.model.CustaggRecordsDTO;
import lombok.extern.log4j.Log4j2;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.annotation.AfterStep;
import org.springframework.batch.core.annotation.BeforeStep;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Enriches raw CustaggRecordsDTO with alpha-entity, deduplicates globally
 * across all partitions, records skip metrics, and guards against single-record
 * failures.
 */
@Log4j2
@Component
public class CustaggProcessor
    implements ItemProcessor<CustaggRecordsDTO, CustaggProcessedRecordsDTO>,
               StepExecutionListener {

    private static final int DEDUP_CACHE_INITIAL_CAPACITY = 1_000_000;

    /** loaded from validation tasklet */
    private Map<String, String> entityMap;

    /** shared across partitions to avoid duplicates */
    private ConcurrentMap<String, Boolean> dedupCache;

    /** metrics */
    private long dupSkipped = 0L;

    // ------------------------------------
    // STEP LISTENER: restore maps once
    // ------------------------------------
    @BeforeStep
    @SuppressWarnings("unchecked")
    public void beforeStep(StepExecution stepExecution) {
        ExecutionContext jobCtx = stepExecution
            .getJobExecution()
            .getExecutionContext();

        // 1) restore the numeric→alpha map
        entityMap = (Map<String, String>) jobCtx.get("entityMap");
        if (entityMap == null) {
            throw new IllegalStateException(
                "CustaggProcessor.beforeStep: entityMap missing from JobExecutionContext");
        }

        // 2) restore or create the dedupe cache
        dedupCache = (ConcurrentMap<String, Boolean>) jobCtx.get("dedupCache");
        if (dedupCache == null) {
            dedupCache = new ConcurrentHashMap<>(DEDUP_CACHE_INITIAL_CAPACITY);
            jobCtx.put("dedupCache", dedupCache);
        }

        log.info("CustaggProcessor.beforeStep ▶ entityMap size={}, dedupCache size={}",
                 entityMap.size(), dedupCache.size());
    }

    @Override
    public void afterStep(StepExecution stepExecution) {
        // store the skip count so listeners can aggregate
        stepExecution.getExecutionContext().putLong("dupSkipped", dupSkipped);
        log.info("CustaggProcessor.afterStep ▶ step='{}', duplicates skipped={}",
                 stepExecution.getStepName(), dupSkipped);
    }

    // ------------------------------------
    // ITEM PROCESSOR
    // ------------------------------------
    @Override
    public CustaggProcessedRecordsDTO process(CustaggRecordsDTO record) {
        log.debug("Processor INPUT ▶ {}", record);

        try {
            // 1) numeric→alpha
            String alpha = entityMap.get(record.getEntity());
            if (alpha == null) {
                log.debug("  ↳ drop: no mapping for numericEntity={}",
                          record.getEntity());
                return null;
            }

            // 2) global dedupe
            String key = record.getProductCode()
                       + '#' + record.getEntity()
                       + '#' + record.getAccountNumber();
            if (dedupCache.putIfAbsent(key, Boolean.TRUE) != null) {
                dupSkipped++;
                log.debug("  ↳ drop: duplicate skipped for key='{}'", key);
                return null;
            }

            // 3) emit enriched DTO
            CustaggProcessedRecordsDTO out = new CustaggProcessedRecordsDTO(
                record.getAccountNumber(),
                record.getEntity(),
                alpha,
                record.getProductCode()
            );
            log.debug("  ↳ emit: {}", out);
            return out;

        } catch (Exception e) {
            // catch-all so one bad record doesn’t kill the step
            log.error("Processor ERROR ▶ record={}, skipping due to exception",
                      record, e);
            // optional: you could increment a separate error counter here
            return null;
        }
    }
}
