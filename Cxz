@Component
@Log4j2
public class CustaggWriter implements ItemWriter<CustaggProcessedRecordsDTO> {

    private final NamedParameterJdbcTemplate namedJdbc;
    private final JdbcTemplate jdbc;

    @Autowired
    public CustaggWriter(NamedParameterJdbcTemplate namedJdbc,
                         JdbcTemplate jdbc) {
        this.namedJdbc = namedJdbc;
        this.jdbc      = jdbc;
    }

    @Override
    public void write(List<? extends CustaggProcessedRecordsDTO> items) {
        if (items == null || items.isEmpty()) {
            log.info("No records to write, skipping.");
            return;
        }

        // 1) build IN-parameters
        Set<String> accNos   = items.stream()
                                    .map(CustaggProcessedRecordsDTO::getAccountNumber)
                                    .collect(Collectors.toSet());
        Set<String> entCodes = items.stream()
                                    .map(CustaggProcessedRecordsDTO::getNumEntity)
                                    .collect(Collectors.toSet());
        Set<String> prods    = items.stream()
                                    .map(CustaggProcessedRecordsDTO::getProductCode)
                                    .collect(Collectors.toSet());

        Map<String,Object> inParams = Map.of(
            "accNos",   accNos,
            "entCodes", entCodes,
            "prods",    prods
        );

        // 2) single UNION fetch
        log.info("Fetching schedule IDs via UNION query…");
        List<String> allSchedIds = namedJdbc.queryForList(
            CustaggSQLFactory.FETCH_SCHEDULE_IDS_UNION,
            inParams,
            String.class
        );
        log.info("Fetched {} schedule IDs", allSchedIds.size());
        if (allSchedIds.isEmpty()) return;

        Timestamp now = Timestamp.from(Instant.now());

        // 3) fetch exec + instr IDs, update in batch as before…
        Map<String,Object> schedParam = Collections.singletonMap("schedIds", allSchedIds);

        List<String> execIds  = namedJdbc.queryForList(
            CustaggSQLFactory.FETCH_TRANSFER_EXECUTION_M2M_ID,
            schedParam,
            String.class
        );
        List<String> instrIds = namedJdbc.queryForList(
            CustaggSQLFactory.FETCH_TRANSFER_INSTRUCTION_ID,
            schedParam,
            String.class
        );

        // 4) batch updates
        batchUpdate("schedule_m2m", allSchedIds, now,
            CustaggSQLFactory.UPDATE_SCHEDULE_M2M, 2, 1);

        batchUpdate("transfer_execution_m2m", execIds, now,
            CustaggSQLFactory.UPDATE_TRANSFER_EXECUTION_M2M, 2, 0);

        batchUpdate("transfer_instruction_m2m", instrIds, now,
            CustaggSQLFactory.UPDATE_TRANSFER_INSTRUCTION_M2M, 2, 0);

        log.info("CustaggWriter complete.");
    }

    private void batchUpdate(String name,
                             List<String> ids,
                             Timestamp ts,
                             String sql,
                             int tsIndex,
                             int idIndex)
    {
        if (ids.isEmpty()) {
            log.info("No {} rows to update", name);
            return;
        }
        List<Object[]> batch = ids.stream()
            .map(id -> {
                Object[] row = new Object[ idIndex+1 ];
                row[tsIndex] = ts;            // either parameter 2 or 1
                row[idIndex] = id;            // either parameter 3 or 2
                return row;
            }).collect(Collectors.toList());

        int[] counts = jdbc.batchUpdate(sql, batch);
        log.info("Updated {} rows in {}", Arrays.stream(counts).sum(), name);
    }
}
