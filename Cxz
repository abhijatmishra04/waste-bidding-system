package com.bofa.sst.batch.util;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import org.junit.Test;
import org.mockito.MockedStatic;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Dependency-free test that drives every public method of {@link LoggingUtil}.
 * Uses Mockito static-mocking instead of Logback's ListAppender.
 */
public class LoggingUtilTest {

    @Test
    public void everyPublicMethod_logsSomething() {

        // 1️⃣  prepare a mock Logger
        Logger mockLog = mock(Logger.class);
        // let every level be enabled so calls go through
        when(mockLog.isInfoEnabled()).thenReturn(true);
        when(mockLog.isErrorEnabled()).thenReturn(true);
        when(mockLog.isDebugEnabled()).thenReturn(true);

        /* 2️⃣  static-mock LoggerFactory.getLogger("splunkAppender") */
        try (MockedStatic<LoggerFactory> lf = mockStatic(LoggerFactory.class)) {
            lf.when(() -> LoggerFactory.getLogger("splunkAppender"))
              .thenReturn(mockLog);

            /* ─── invoke every overload ─── */
            LoggingUtil.logJobMessage(111L, "job-info");
            LoggingUtil.logJobError  (111L, "job-err");

            LoggingUtil.logMessage("ACC", "A1", "simple-info");
            LoggingUtil.logErrorMessage("ACC", "A1", "simple-err");

            LoggingUtil.logJobMessage(222L, "ENT", "E2", "full-info");
            LoggingUtil.logError    (222L, "ENT", "E2", "full-err");

            LoggingUtil.logTransactionTraceLogger(
                    "CRM", "MSG-01", "Sync", "payload", true);

            /* ─── assertions: at least one info and one error call recorded ─── */
            verify(mockLog, atLeastOnce()).info(anyString());
            verify(mockLog, atLeastOnce()).error(anyString());
        }
    }
}
