package com.bofa.sst.batch.core.impl;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.*;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.*;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;

/**
 * 100 % line + branch coverage for {@link CustaggWriter}, Java 8 compatible.
 */
@RunWith(MockitoJUnitRunner.class)
public class CustaggWriterTest {

    /* ────────────────── collaborators ────────────────── */
    @Mock private NamedParameterJdbcTemplate npJdbc;
    @Mock private JdbcTemplate               jdbc;

    private CustaggWriter writer;
    private StepExecution step;

    @Rule public ExpectedException thrown = ExpectedException.none();

    @Before
    public void init() {
        writer = new CustaggWriter(npJdbc, jdbc);

        JobExecution je = new JobExecution(1L);
        step            = new StepExecution("custaggStep", je);
        step.setCommitCount(100);
        writer.captureStepExecution(step);      // simulates @BeforeStep
    }

    /* ─────────── 1. Happy-path flow ─────────── */
    @Test
    public void should_fetchAndUpdateAllThreeTables_andPushMetrics() throws Exception {

        /* ----- stub SELECTs (3 calls) ----- */
        final AtomicInteger sel = new AtomicInteger();
        when(npJdbc.queryForList(anyString(),
                                 ArgumentMatchers.<Map<String, Object>>any(),
                                 eq(String.class)))
        .thenAnswer(invocation -> {
            int n = sel.getAndIncrement();
            if (n == 0) { // schedule IDs
                return Arrays.asList("SCH1", "SCH2");
            } else if (n == 1) { // execution IDs
                return Collections.singletonList("EX1");
            } else {             // instruction IDs
                return Arrays.asList("IN1", "IN2");
            }
        });

        /* ----- stub UPDATEs (rowsAffected = 1 per id) ----- */
        when(jdbc.batchUpdate(anyString(),
                              ArgumentMatchers.<List<String>>anyList(),
                              anyInt(),
                              ArgumentMatchers.<ParameterizedPreparedStatementSetter<String>>any()))
        .thenAnswer(invocation -> {
            int size = ((List<?>) invocation.getArgument(1)).size();
            int[][] rc = new int[size][1];
            for (int i = 0; i < size; i++) { rc[i][0] = 1; }
            return rc;
        });

        /* ----- execute ----- */
        writer.write(Arrays.asList(
                dto("ACC1", "E01", "P01"),
                dto("ACC2", "E01", "P01")));
        writer.flushMetrics();                      // simulates @AfterStep

        /* ----- verify JDBC interaction ----- */
        verify(npJdbc, times(3))
              .queryForList(anyString(),
                            ArgumentMatchers.<Map<String, Object>>any(),
                            eq(String.class));
        verify(jdbc,  times(3))
              .batchUpdate(anyString(),
                           ArgumentMatchers.<List<String>>anyList(),
                           anyInt(),
                           ArgumentMatchers.<ParameterizedPreparedStatementSetter<String>>any());

        /* ----- verify metrics pushed into EC ----- */
        ExecutionContext ec = step.getExecutionContext();
        assertThat(ec.getLong("schedFetched"), is(2L));
        assertThat(ec.getLong("execFetched") , is(1L));
        assertThat(ec.getLong("instrFetched"), is(2L));
        assertThat(ec.getLong("schedUpdated"), is(2L));
        assertThat(ec.getLong("execUpdated") , is(1L));
        assertThat(ec.getLong("instrUpdated"), is(2L));
    }

    /* ─────────── 2. Empty chunk ─────────── */
    @Test
    public void write_withEmptyChunk_doesNothing() throws Exception {
        writer.write(Collections.emptyList());

        verifyNoInteractions(npJdbc, jdbc);
        assertTrue(step.getExecutionContext().isEmpty());
    }

    /* ───── 3. No schedule IDs: fetch done, update skipped ───── */
    @Test
    public void write_whenNoScheduleIds_skipsRest() throws Exception {
        when(npJdbc.queryForList(anyString(),
                                 ArgumentMatchers.<Map<String, Object>>any(),
                                 eq(String.class)))
            .thenReturn(Collections.emptyList());

        writer.write(Collections.singletonList(dto("ACC1", "E01", "P01")));

        verify(npJdbc, times(1))
              .queryForList(anyString(),
                            ArgumentMatchers.<Map<String, Object>>any(),
                            eq(String.class));
        verifyNoInteractions(jdbc);
        assertEquals(0L, step.getExecutionContext().getLong("schedUpdated", 0L));
    }

    /* ───── 4. Exception path: partial metrics + re-throw ───── */
    @Test
    public void write_whenSelectFails_pushesPartialMetrics_andRethrows() throws Exception {
        when(npJdbc.queryForList(anyString(),
                                 ArgumentMatchers.<Map<String, Object>>any(),
                                 eq(String.class)))
            .thenThrow(new DataAccessException("boom") { private static final long serialVersionUID = 1L; });

        thrown.expect(DataAccessException.class);

        try {
            writer.write(Collections.singletonList(dto("ACC1", "E01", "P01")));
        } finally {
            assertTrue(step.getExecutionContext().containsKey("schedFetched"));
            assertEquals(0L, step.getExecutionContext().getLong("schedUpdated"));
        }
    }

    /* ───── 5. fetchPaged(): branch with >990 literals ───── */
    @Test
    public void fetchPaged_withHugeSet_splitsIntoSlices() throws Exception {
        List<String> huge = new ArrayList<>();
        for (int i = 0; i < 1_001; i++) { huge.add("ID" + i); }

        when(npJdbc.queryForList(anyString(),
                                 ArgumentMatchers.<Map<String, Object>>any(),
                                 eq(String.class)))
        .thenAnswer(invocation -> {
            @SuppressWarnings("unchecked")
            Collection<String> slice =
                (Collection<String>) ((Map<?, ?>) invocation.getArgument(1))
                                       .values()
                                       .iterator()
                                       .next();
            return new ArrayList<String>(slice);   // explicit generic
        });

        Method m = CustaggWriter.class.getDeclaredMethod(
                "fetchPaged",
                String.class, Map.class, List.class);
        m.setAccessible(true);

        @SuppressWarnings("unchecked")
        List<String> result = (List<String>) m.invoke(
                writer,
                "dummySql",
                Collections.singletonMap("accNos", huge),
                Collections.singletonList("accNos"));

        assertEquals(1_001, result.size());
        verify(npJdbc, atLeast(2))
              .queryForList(anyString(),
                            ArgumentMatchers.<Map<String, Object>>any(),
                            eq(String.class));
    }

    /* ───── 6. batchUpdatePaged(): param-count 2 & 3, two slices ───── */
    @Test
    public void batchUpdatePaged_affectsAllRows_forBothVariants() throws Exception {
        List<String> ids = new ArrayList<>();
        for (int i = 0; i < 1_100; i++) { ids.add("ID" + i); }  // two slices

        when(jdbc.batchUpdate(anyString(),
                              ArgumentMatchers.<List<String>>anyList(),
                              anyInt(),
                              ArgumentMatchers.<ParameterizedPreparedStatementSetter<String>>any()))
        .thenAnswer(invocation -> {
            int size = ((List<?>) invocation.getArgument(1)).size();
            int[][] rc = new int[size][1];
            for (int i = 0; i < size; i++) { rc[i][0] = 1; }
            return rc;
        });

        Method m = CustaggWriter.class.getDeclaredMethod(
                "batchUpdatePaged",
                String.class, Timestamp.class, List.class, int.class);
        m.setAccessible(true);

        int upd3 = (Integer) m.invoke(
                writer, "SQL", Timestamp.from(Instant.now()), ids, 3);
        int upd2 = (Integer) m.invoke(
                writer, "SQL", Timestamp.from(Instant.now()), ids, 2);

        assertEquals(1_100, upd3);
        assertEquals(1_100, upd2);
        verify(jdbc, times(4))  // 2 slices × 2 invocations
              .batchUpdate(anyString(),
                           ArgumentMatchers.<List<String>>anyList(),
                           anyInt(),
                           ArgumentMatchers.<ParameterizedPreparedStatementSetter<String>>any());
    }

    /* ─────────── helper: tiny DTO factory ─────────── */
    private static CustaggProcessedRecordsDTO dto(String acc, String ent, String prod) {
        CustaggProcessedRecordsDTO d = new CustaggProcessedRecordsDTO();
        d.setAccountNumber(acc);
        d.setNumEntity(ent);
        d.setProductCode(prod);
        return d;
    }
}
