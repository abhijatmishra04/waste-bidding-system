package com.bofa.sst.batch.core;

import com.bofa.sst.batch.dto.CustaggProcessedRecordsDTO;
import com.bofa.sst.batch.dto.CustaggRecordsDTO;
import lombok.extern.log4j.Log4j2;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.ExecutionContext;
import org.springframework.batch.core.annotation.BeforeStep;
import org.springframework.batch.core.annotation.AfterStep;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Enriches raw CustaggRecordsDTO with alpha-entity, deduplicates globally
 * across all partitions, and records duplicate-skip metrics.
 */
@Log4j2
@Component
public class CustaggProcessor implements ItemProcessor<CustaggRecordsDTO, CustaggProcessedRecordsDTO> {

    private Map<String, String> entityMap;
    private ConcurrentMap<String, Boolean> dedupCache;
    private long dupSkipped = 0;

    /**
     * Initializes the entityMap (from validation tasklet) and
     * a shared dedupCache in the JobExecutionContext.
     */
    @BeforeStep
    @SuppressWarnings("unchecked")
    public void beforeStep(StepExecution stepExecution) {
        ExecutionContext jobCtx = stepExecution.getJobExecution().getExecutionContext();

        // 1) restore the numeric→alpha entity map
        entityMap = (Map<String, String>) jobCtx.get("entityMap");
        if (entityMap == null) {
            throw new IllegalStateException("entityMap missing from JobExecutionContext");
        }

        // 2) build or restore the job-wide dedup cache
        dedupCache = (ConcurrentMap<String, Boolean>) jobCtx.get("dedupCache");
        if (dedupCache == null) {
            dedupCache = new ConcurrentHashMap<>(1_000_000);
            jobCtx.put("dedupCache", dedupCache);
        }

        log.info("Processor initialized: entityMap size={}, dedupCache size={}",
                 entityMap.size(), dedupCache.size());
    }

    /**
     * For each record:
     * 1) map numeric→alpha entity (skip if missing),
     * 2) dedupe on product#numericEntity#accountNumber (skip duplicates),
     * 3) emit CustaggProcessedRecordsDTO.
     */
    @Override
    public CustaggProcessedRecordsDTO process(CustaggRecordsDTO record) {
        // entity mapping
        String alpha = entityMap.get(record.getNumericEntity());
        if (alpha == null) {
            log.debug("Skipping record: no mapping for numericEntity={}", record.getNumericEntity());
            return null;
        }

        // global dedup
        String key = record.getProductCode()
                   + '#' + record.getNumericEntity()
                   + '#' + record.getAccountNumber();
        if (dedupCache.putIfAbsent(key, Boolean.TRUE) != null) {
            dupSkipped++;
            log.debug("Duplicate skipped: {}", key);
            return null;
        }

        // emit enriched DTO
        return new CustaggProcessedRecordsDTO(
            record.getAccountNumber(),
            record.getNumericEntity(),
            alpha,
            record.getProductCode()
        );
    }

    /**
     * After the step, store dupSkipped so the Job listener can aggregate.
     */
    @AfterStep
    public void afterStep(StepExecution stepExecution) {
        ExecutionContext stepCtx = stepExecution.getExecutionContext();
        stepCtx.putLong("dupSkipped", dupSkipped);
        log.info("Step '{}' completed, duplicates skipped={}",
                 stepExecution.getStepName(), dupSkipped);
    }
}
