package com.bofa.sst.batch.core.impl;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import org.junit.*;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.*;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementSetter;

/**
 * 100 % line + branch coverage for {@link CustaggWriter}, compilable on Java 8
 * with junit-4.13, mockito-inline-3.8.0, spring-batch-core 5 .x.
 */
@RunWith(MockitoJUnitRunner.class)
public class CustaggWriterTest {

    /* ────────────────────────────────── collaborators ───────────────────────── */
    @Mock private NamedParameterJdbcTemplate npJdbc;
    @Mock private JdbcTemplate               jdbc;

    private CustaggWriter writer;          // unit under test
    private StepExecution step;            // fake step context

    @Rule public ExpectedException thrown = ExpectedException.none();

    @Before
    public void init() {
        writer = new CustaggWriter(npJdbc, jdbc);

        JobExecution je = new JobExecution(1L);
        step            = new StepExecution("custaggStep", je);
        step.setCommitCount(100);
        writer.captureStepExecution(step);            // simulates @BeforeStep
    }

    /* ───────────────────────────── 1. Happy-path flow ───────────────────────── */
    @Test
    public void should_fetchAndUpdateAllThreeTables_andPushMetrics() throws Exception {

        /* ----- stub three SELECTs ----- */
        AtomicInteger sel = new AtomicInteger();
        when(npJdbc.queryForList(
                    anyString(),
                    ArgumentMatchers.<Map<String,Object>>any(),
                    eq(String.class)))
        .thenAnswer(inv -> {
            int n = sel.getAndIncrement();
            if (n == 0) {              // schedule IDs
                return Arrays.asList("SCH1", "SCH2");
            } else if (n == 1) {       // execution IDs
                return Collections.singletonList("EX1");
            } else {                   // instruction IDs
                return Arrays.asList("IN1", "IN2");
            }
        });

        /* ----- stub three UPDATE slices (rowsAffected = 1 per id) ----- */
        when(jdbc.batchUpdate(
                    anyString(),
                    ArgumentMatchers.<List<String>>anyList(),
                    anyInt(),
                    any(PreparedStatementSetter.class)))
        .thenAnswer(inv -> {
            int n   = ((List<?>) inv.getArgument(1)).size();
            int[][] rc = new int[n][1];
            Arrays.stream(rc).forEach(r -> r[0] = 1);
            return rc;
        });

        /* ----- exercise ----- */
        writer.write(Arrays.asList(
                dto("ACC1", "E01", "P01"),
                dto("ACC2", "E01", "P01")));
        writer.flushMetrics();                       // simulates @AfterStep

        /* ----- verify JDBC usage ----- */
        verify(npJdbc, times(3))
              .queryForList(anyString(),
                            ArgumentMatchers.<Map<String,Object>>any(),
                            eq(String.class));
        verify(jdbc, times(3))
              .batchUpdate(anyString(),
                           ArgumentMatchers.<List<String>>anyList(),
                           anyInt(),
                           any(PreparedStatementSetter.class));

        /* ----- verify metrics ----- */
        ExecutionContext ec = step.getExecutionContext();
        assertThat(ec.getLong("schedFetched"), is(2L));
        assertThat(ec.getLong("execFetched") , is(1L));
        assertThat(ec.getLong("instrFetched"), is(2L));
        assertThat(ec.getLong("schedUpdated"), is(2L));
        assertThat(ec.getLong("execUpdated") , is(1L));
        assertThat(ec.getLong("instrUpdated"), is(2L));
    }

    /* ─────────────────────── 2. Empty chunk → early return ──────────────────── */
    @Test
    public void write_withEmptyChunk_doesNothing() throws Exception {
        writer.write(Collections.emptyList());

        verifyNoInteractions(npJdbc, jdbc);
        assertTrue(step.getExecutionContext().isEmpty());
    }

    /* ─────────────── 3. No schedule IDs → fetch done, update skipped ────────── */
    @Test
    public void write_whenNoScheduleIds_skipsRest() throws Exception {
        when(npJdbc.queryForList(anyString(),
                                 ArgumentMatchers.<Map<String,Object>>any(),
                                 eq(String.class)))
            .thenReturn(Collections.emptyList());   // first SELECT returns 0 rows

        writer.write(Collections.singletonList(dto("ACC1", "E01", "P01")));

        verify(npJdbc, times(1))
              .queryForList(anyString(),
                            ArgumentMatchers.<Map<String,Object>>any(),
                            eq(String.class));
        verifyNoInteractions(jdbc);                 // never updates
        assertEquals(0L, step.getExecutionContext().getLong("schedUpdated", 0L));
    }

    /* ───────────── 4. Exception during SELECT → partial metrics & rethrow ───── */
    @Test
    public void write_whenSelectFails_pushesPartialMetrics_andRethrows() throws Exception {
        when(npJdbc.queryForList(anyString(),
                                 ArgumentMatchers.<Map<String,Object>>any(),
                                 eq(String.class)))
            .thenThrow(new DataAccessException("boom") { private static final long serialVersionUID = 1L; });

        thrown.expect(DataAccessException.class);

        try {
            writer.write(Collections.singletonList(dto("ACC1", "E01", "P01")));
        } finally {
            assertTrue(step.getExecutionContext().containsKey("schedFetched"));
            assertEquals(0L, step.getExecutionContext().getLong("schedUpdated"));
        }
    }

    /* ─────────── 5. Private helper fetchPaged() – >990 literals branch ─────── */
    @Test
    public void fetchPaged_withHugeSet_splitsIntoSlices() throws Exception {
        List<String> huge = new ArrayList<>();
        for (int i = 0; i < 1_001; i++) huge.add("ID" + i);   // triggers paging

        when(npJdbc.queryForList(anyString(),
                                 ArgumentMatchers.<Map<String,Object>>any(),
                                 eq(String.class)))
            .thenAnswer(inv -> new ArrayList<>(
                    ((Map<?,?>) inv.getArgument(1)).values().iterator().next()));

        Method m = CustaggWriter.class.getDeclaredMethod("fetchPaged",
                String.class, Map.class, List.class);
        m.setAccessible(true);

        @SuppressWarnings("unchecked")
        List<String> result = (List<String>) m.invoke(writer,
                "dummySql",
                Collections.singletonMap("accNos", huge),
                Collections.singletonList("accNos"));

        assertEquals(1_001, result.size());
        verify(npJdbc, atLeast(2))
              .queryForList(anyString(),
                            ArgumentMatchers.<Map<String,Object>>any(),
                            eq(String.class));
    }

    /* ── 6. Private helper batchUpdatePaged() – param-count 2 & 3, two slices ── */
    @Test
    public void batchUpdatePaged_affectsAllRows_forBothVariants() throws Exception {
        List<String> ids = new ArrayList<>();
        for (int i = 0; i < 1_100; i++) ids.add("ID" + i);    // 1 000 + 100

        when(jdbc.batchUpdate(anyString(),
                              ArgumentMatchers.<List<String>>anyList(),
                              anyInt(),
                              any(PreparedStatementSetter.class)))
        .thenAnswer(inv -> {
            int n = ((List<?>) inv.getArgument(1)).size();
            int[][] rc = new int[n][1];
            Arrays.stream(rc).forEach(r -> r[0] = 1);
            return rc;
        });

        Method m = CustaggWriter.class.getDeclaredMethod("batchUpdatePaged",
                String.class, Timestamp.class, List.class, int.class);
        m.setAccessible(true);

        int upd3 = (int) m.invoke(writer, "SQL",
                Timestamp.from(Instant.now()), ids, 3);
        int upd2 = (int) m.invoke(writer, "SQL",
                Timestamp.from(Instant.now()), ids, 2);

        assertEquals(1_100, upd3);
        assertEquals(1_100, upd2);
        verify(jdbc, times(4))  // 2 slices × 2 calls
              .batchUpdate(anyString(),
                           ArgumentMatchers.<List<String>>anyList(),
                           anyInt(),
                           any(PreparedStatementSetter.class));
    }

    /* ─────────────────────────── helper : tiny DTO factory ──────────────────── */
    private static CustaggProcessedRecordsDTO dto(String acc, String ent, String prod) {
        CustaggProcessedRecordsDTO d = new CustaggProcessedRecordsDTO();
        d.setAccountNumber(acc);
        d.setNumEntity(ent);
        d.setProductCode(prod);
        return d;
    }
}
