
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
RAI Gateway client with Locust custom-event metrics (single process)
- SSRAI SDK untouched (no gevent monkey-patching)
- Retries + exponential backoff + circuit breaker
- Real-time Locust metrics via custom event (avg/p50/p95/success rate/RPS)
- Optional background snapshot logger
"""

import os
import time
import json
import random
import logging
import threading
from logging.handlers import RotatingFileHandler
from typing import Any, Dict, List, Optional

# Locust (no monkey patching)
os.environ.setdefault("LOCUST_NO_MONKEY_PATCH", "1")
from locust.env import Environment
from locust.event import EventHook

# SSRAI SDK
from ssrai import SSRAIClient


# ---------- logging ----------
def setup_rot_logger(name: str, path: str) -> logging.Logger:
    lg = logging.getLogger(name)
    lg.setLevel(logging.INFO)
    lg.propagate = False
    if not lg.handlers:
        os.makedirs(os.path.dirname(os.path.abspath(path)), exist_ok=True)
        fh = RotatingFileHandler(path, maxBytes=10 * 1024 * 1024, backupCount=3)
        fh.setFormatter(logging.Formatter("%(message)s"))
        lg.addHandler(fh)
    return lg


# ---------- circuit breaker ----------
class CircuitBreaker:
    def __init__(self, fail_threshold: int = 10, half_open_after: float = 30.0):
        self.state = "CLOSED"  # CLOSED | OPEN | HALF_OPEN
        self.fail_count = 0
        self.opened_at = 0.0
        self.fail_threshold = fail_threshold
        self.half_open_after = half_open_after
        self._lock = threading.Lock()

    def allow(self) -> bool:
        with self._lock:
            if self.state == "OPEN" and (time.time() - self.opened_at) > self.half_open_after:
                self.state = "HALF_OPEN"
            return self.state != "OPEN"

    def on_success(self):
        with self._lock:
            self.fail_count = 0
            self.state = "CLOSED"

    def on_failure(self):
        with self._lock:
            self.fail_count += 1
            if self.fail_count >= self.fail_threshold and self.state != "OPEN":
                self.state = "OPEN"
                self.opened_at = time.time()

    def get_state(self) -> str:
        with self._lock:
            return self.state


# ---------- locust metrics with custom event ----------
class LocustMetrics:
    """
    Owns a Locust Environment and a custom EventHook.
    Firing the event updates Locust's RequestStats.
    """

    def __init__(self):
        self.env = Environment(user_classes=[])
        # Important: initialize a local runner so env.events.request is wired to stats
        self.env.create_local_runner()
        self.event = EventHook()
        self._attach()

    def _attach(self):
        def _on_event(model: str, latency_ms: float, success: bool, error: Optional[str]):
            # Feed Locust's built-in request event
            if success:
                try:
                    self.env.events.request.fire(
                        request_type="SSRAI",
                        name=model,
                        response_time=latency_ms,
                        response_length=0,
                        exception=None,
                    )
                except TypeError:
                    # Older Locust versions
                    self.env.events.request.fire(
                        request_type="SSRAI",
                        name=model,
                        response_time=latency_ms,
                        exception=None,
                    )
            else:
                err = RuntimeError(error or "error")
                try:
                    self.env.events.request.fire(
                        request_type="SSRAI",
                        name=model,
                        response_time=latency_ms,
                        response_length=0,
                        exception=err,
                    )
                except TypeError:
                    self.env.events.request.fire(
                        request_type="SSRAI",
                        name=model,
                        response_time=latency_ms,
                        exception=err,
                    )

        self.event.add_listener(_on_event)

    def fire(self, model: str, latency_ms: float, success: bool, error: Optional[str] = None):
        self.event.fire(model=model, latency_ms=latency_ms, success=success, error=error)

    def snapshot_total(self) -> Dict[str, Any]:
        s = self.env.stats.total
        return {
            "ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()),
            "total_requests": s.num_requests,
            "failures": s.num_failures,
            "success_rate_pct": round(((s.num_requests - s.num_failures) / s.num_requests * 100) if s.num_requests else 0.0, 2),
            "avg_latency_ms": round(getattr(s, "avg_response_time", 0.0), 2),
            "p50_latency_ms": round(s.get_response_time_percentile(0.50) or 0.0, 2),
            "p95_latency_ms": round(s.get_response_time_percentile(0.95) or 0.0, 2),
            "current_rps": round(getattr(s, "current_rps", 0.0), 2),
        }

    def snapshot_per_model(self) -> Dict[str, Dict[str, Any]]:
        out: Dict[str, Dict[str, Any]] = {}
        for (req_type, name), entry in list(self.env.stats.entries.items()):
            if req_type != "SSRAI":
                continue
            out[name] = {
                "requests": entry.num_requests,
                "failures": entry.num_failures,
                "avg_ms": round(entry.avg_response_time, 2),
                "p50_ms": round(entry.get_response_time_percentile(0.50) or 0.0, 2),
                "p95_ms": round(entry.get_response_time_percentile(0.95) or 0.0, 2),
            }
        return out


# ---------- rai gateway client ----------
class RAIGatewayClient:
    """
    - Wraps SSRAIClient
    - Retries + exponential backoff + circuit breaker
    - Fires custom Locust event per attempt (success/failure)
    - Exposes total and per-model snapshots
    """

    def __init__(
        self,
        config_file: str,
        profile: Optional[str] = None,
        *,
        max_retries: int = 3,
        backoff_base_seconds: float = 0.5,
        backoff_max_seconds: float = 10.0,
        max_total_retry_seconds: float = 30.0,
        breaker_fail_threshold: int = 10,
        breaker_half_open_after: float = 30.0,
        events_log: str = "logs/rai_client_events.jsonl",
        extra_fields: Optional[Dict[str, Any]] = None,
    ):
        self.cli = SSRAIClient(config_file=config_file, profile=profile)
        if getattr(self.cli, "auth_type", None) == "pat" and not getattr(self.cli, "pat_token", None):
            env_pat = os.getenv("SSRAI_PAT_TOKEN")
            if env_pat:
                self.cli.pat_token = env_pat

        self.max_retries = int(max_retries)
        self.backoff_base_seconds = float(backoff_base_seconds)
        self.backoff_max_seconds = float(backoff_max_seconds)
        self.max_total_retry_seconds = float(max_total_retry_seconds)
        self.breaker = CircuitBreaker(breaker_fail_threshold, breaker_half_open_after)

        self.metrics = LocustMetrics()

        self._events_logger = setup_rot_logger("rai.events", events_log)
        self._extra = extra_fields or {}

    def _log(self, event: str, **kv):
        rec = {
            "ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()),
            "event": event,
            **self._extra,
            **kv,
        }
        self._events_logger.info(json.dumps(rec, ensure_ascii=False))

    def _backoff(self, attempt: int) -> float:
        base = self.backoff_base_seconds * (2 ** attempt)
        return random.uniform(0, min(base, self.backoff_max_seconds))

    def call_chat(
        self,
        messages: List[Dict[str, Any]],
        model: str,
        *,
        max_tokens: int = 512,
        temperature: float = 0.0,
        guardrail_profile: Optional[str] = None,
    ) -> Dict[str, Any]:
        if not self.breaker.allow():
            self.metrics.fire(model, 0.0, False, "Circuit.Open")
            self._log("breaker_open", model=model)
            raise RuntimeError("Circuit breaker OPEN")

        start_overall = time.perf_counter()
        last_exc: Optional[Exception] = None

        for attempt in range(self.max_retries + 1):
            t0 = time.perf_counter()
            self._log("attempt_start", attempt=attempt + 1, model=model)

            try:
                resp = self.cli.chat.create(
                    model=model,
                    messages=messages,
                    max_tokens=max_tokens,
                    temperature=temperature,
                    guardrail_profile=guardrail_profile,
                )
                latency_ms = (time.perf_counter() - t0) * 1000.0
                self.breaker.on_success()
                self.metrics.fire(model, latency_ms, True)
                self._log("attempt_end", status="success", latency_ms=round(latency_ms, 2), model=model)
                return resp

            except Exception as e:
                last_exc = e
                latency_ms = (time.perf_counter() - t0) * 1000.0
                self.breaker.on_failure()
                self.metrics.fire(model, latency_ms, False, str(e))
                self._log("attempt_end", status="failure", error=str(e), latency_ms=round(latency_ms, 2), model=model)

                elapsed = time.perf_counter() - start_overall
                final = (attempt >= self.max_retries) or (elapsed >= self.max_total_retry_seconds)
                if final:
                    break
                time.sleep(self._backoff(attempt))

        raise RuntimeError(f"RAI call failed after retries: {last_exc}")

    def get_locust_metrics_total(self) -> Dict[str, Any]:
        return self.metrics.snapshot_total()

    def get_locust_metrics_per_model(self) -> Dict[str, Dict[str, Any]]:
        return self.metrics.snapshot_per_model()

    def start_metrics_logger(self, interval_sec: int = 5, out_path: str = "logs/locust_metrics.jsonl") -> threading.Thread:
        os.makedirs(os.path.dirname(os.path.abspath(out_path)), exist_ok=True)
        log = setup_rot_logger("locust.metrics", out_path)

        def _loop():
            while True:
                try:
                    snap = {
                        **self.get_locust_metrics_total(),
                        "per_model": self.get_locust_metrics_per_model(),
                    }
                    log.info(json.dumps(snap, ensure_ascii=False))
                except Exception as e:
                    self._log("metrics_logger_error", error=str(e))
                time.sleep(interval_sec)

        th = threading.Thread(target=_loop, name="LocustMetricsLogger", daemon=True)
        th.start()
        return th
