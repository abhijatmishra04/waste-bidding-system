package com.bofa.sst.batch.core.impl;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import org.springframework.batch.core.ExecutionContext;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.annotation.AfterStep;
import org.springframework.batch.core.annotation.BeforeStep;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.stereotype.Component;

import com.bofa.sst.batch.model.CustaggProcessedRecordsDTO;
import com.bofa.sst.batch.model.CustaggRecordsDTO;

import lombok.extern.log4j.Log4j2;

/**
 * Enrich raw CustaggRecordsDTO with alpha-entity, deduplicate globally on
 * productCode#numericEntity#accountNumber, and emit CustaggProcessedRecordsDTO.
 */
@Log4j2
@Component
public class CustaggProcessor
        implements ItemProcessor<CustaggRecordsDTO, CustaggProcessedRecordsDTO> {

    /* ---------- state restored / shared via ExecutionContext ---------- */
    /** numeric→alpha entity map produced by the validation step. */
    private Map<String, String> entityMap;

    /** Job-wide cache to guarantee dedup across all partitions. */
    private ConcurrentMap<String, Boolean> dedupCache;

    /** Per-step counter for duplicates skipped. */
    private long dupSkipped = 0;

    /* --------------------------- lifecycle hooks --------------------------- */

    @SuppressWarnings("unchecked")
    @BeforeStep
    public void beforeStep(StepExecution stepExecution) {
        ExecutionContext jobCtx = stepExecution.getJobExecution().getExecutionContext();

        entityMap = (Map<String, String>) jobCtx.get("entityMap");
        if (entityMap == null) {
            throw new IllegalStateException("entityMap missing from JobExecutionContext");
        }

        dedupCache = (ConcurrentMap<String, Boolean>) jobCtx.get("dedupCache");
        if (dedupCache == null) {
            dedupCache = new ConcurrentHashMap<>(1_000_000);
            jobCtx.put("dedupCache", dedupCache);
        }

        log.info("CustaggProcessor initialised – entityMap size={}, dedupCache size={}",
                 entityMap.size(), dedupCache.size());
    }

    /* ------------------------------ processing ----------------------------- */

    @Override
    public CustaggProcessedRecordsDTO process(CustaggRecordsDTO record) {
        if (record == null) {
            log.warn("Skipping null record");
            return null;
        }

        try {
            /* ---- 1. entity mapping ---- */
            String alpha = entityMap.get(record.getEntity());
            if (alpha == null) {
                log.debug("Skipping – no alpha mapping for numericEntity={}", record.getEntity());
                return null;
            }

            /* ---- 2. global dedup ---- */
            String key = new StringBuilder()
                    .append(record.getProductCode()).append('#')
                    .append(record.getEntity()).append('#')
                    .append(record.getAccountNumber())
                    .toString();

            if (dedupCache.putIfAbsent(key, Boolean.TRUE) != null) {
                dupSkipped++;
                log.debug("Duplicate skipped – key={}", key);
                return null;
            }

            /* ---- 3. emit enriched DTO ---- */
            CustaggProcessedRecordsDTO dto = new CustaggProcessedRecordsDTO(
                    record.getAccountNumber(),
                    record.getEntity(),
                    alpha,
                    record.getProductCode()
            );

            // NEW: log the object that is handed to the writer
            log.debug("Emitting DTO -> {}", dto);

            return dto;

        } catch (Exception ex) {
            // Log + propagate so Spring Batch can apply skip/retry policy
            log.error("Processing failed for record={}, reason={}", record, ex.toString(), ex);
            throw ex;
        }
    }

    /* ------------------------------ tear-down ------------------------------ */

    @AfterStep
    public void afterStep(StepExecution stepExecution) {
        ExecutionContext stepCtx = stepExecution.getExecutionContext();
        stepCtx.putLong("dupSkipped", dupSkipped);

        log.info("Step '{}' completed – duplicates skipped={}",
                 stepExecution.getStepName(), dupSkipped);
    }
}
