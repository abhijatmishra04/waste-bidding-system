import os, time, math, json, logging, threading, random
from collections import deque
from typing import Any, Callable, Deque, Dict, List, Optional
from ssrai import SSRAIClient

# ---------- logger ----------
logger = logging.getLogger("RAIGatewayClient")
logger.setLevel(logging.INFO)
_handler = logging.StreamHandler()
_handler.setFormatter(logging.Formatter("%(message)s"))
if not logger.handlers:
    logger.addHandler(_handler)

# ---------- circuit breaker ----------
class CircuitBreaker:
    def __init__(self, fail_threshold: int = 10, half_open_after: float = 30.0):
        self.state = "CLOSED"
        self.fail_count = 0
        self.opened_at = 0.0
        self.fail_threshold = fail_threshold
        self.half_open_after = half_open_after
        self._lock = threading.Lock()
    def allow(self) -> bool:
        with self._lock:
            if self.state == "OPEN" and (time.time() - self.opened_at) > self.half_open_after:
                self.state = "HALF_OPEN"
            return self.state != "OPEN"
    def on_success(self) -> None:
        with self._lock:
            self.fail_count = 0
            self.state = "CLOSED"
    def on_failure(self) -> None:
        with self._lock:
            self.fail_count += 1
            if self.fail_count >= self.fail_threshold and self.state != "OPEN":
                self.state = "OPEN"; self.opened_at = time.time()
    def get_state(self) -> str:
        with self._lock: return self.state

class RAIError(Exception):
    def __init__(self, code: str, message: str):
        super().__init__(message); self.code = code

class RAIGatewayClient:
    """
    EXACTLY like your agent:
      - Internally uses SSRAIClient(config_file=..., profile=...)
      - Adds: retries + exp backoff + jitter, circuit breaker, p50/p95 metrics, JSON logs, failure callback
      - No custom OAuth in here. SSRAI handles PAT/OAuth the same as your agent.
    """
    def __init__(
        self,
        config_file: str,
        profile: Optional[str] = None,
        max_retries: int = 3,
        backoff_base_seconds: float = 0.5,
        backoff_max_seconds: float = 8.0,
        max_total_retry_seconds: float = 30.0,
        metrics_window_size: int = 5000,
        breaker_fail_threshold: int = 10,
        breaker_half_open_after: float = 30.0,
        on_failure: Optional[Callable[[Dict[str, Any]], None]] = None,
        extra_log_fields: Optional[Dict[str, Any]] = None,
    ):
        self.cli = SSRAIClient(config_file=config_file, profile=profile)

        # PAT auto-source like your agent environment
        if getattr(self.cli, "auth_type", None) == "pat" and not getattr(self.cli, "pat_token", None):
            env_pat = os.getenv("SSRAI_PAT_TOKEN")
            if env_pat:
                self.cli.pat_token = env_pat
                logger.info(json.dumps({"event":"pat_injected","source":"env:SSRAI_PAT_TOKEN"}))

        self.max_retries = max_retries
        self.backoff_base_seconds = backoff_base_seconds
        self.backoff_max_seconds = backoff_max_seconds
        self.max_total_retry_seconds = max_total_retry_seconds
        self.on_failure = on_failure
        self.extra_log_fields = extra_log_fields or {}

        self._latencies_ms: Deque[float] = deque(maxlen=int(metrics_window_size))
        self._total_calls = 0; self._failures = 0
        self._lock = threading.Lock()
        self._breaker = CircuitBreaker(breaker_fail_threshold, breaker_half_open_after)

    # ---- helpers ----
    def _compute_backoff(self, attempt: int) -> float:
        base = self.backoff_base_seconds * (2 ** attempt)
        return random.uniform(0, min(base, self.backoff_max_seconds))

    @staticmethod
    def _percentile(sorted_vals: List[float], p: float) -> float:
        if not sorted_vals: return 0.0
        k = (len(sorted_vals)-1) * (p/100.0)
        f, c = math.floor(k), math.ceil(k)
        if f == c: return sorted_vals[int(k)]
        return sorted_vals[f]*(c-k) + sorted_vals[c]*(k-f)

    def get_metrics(self) -> Dict[str, Any]:
        with self._lock:
            vals = list(self._latencies_ms); total = self._total_calls; fails = self._failures
        vals.sort()
        avg = sum(vals)/len(vals) if vals else 0.0
        p50 = self._percentile(vals, 50.0) if vals else 0.0
        p95 = self._percentile(vals, 95.0) if vals else 0.0
        success_rate = ((total - fails)/total*100.0) if total else 0.0
        return {
            "total_calls": total, "failures": fails,
            "success_rate_pct": round(success_rate,2),
            "avg_latency_ms": round(avg,2),
            "p50_latency_ms": round(p50,2),
            "p95_latency_ms": round(p95,2),
            "breaker_state": self._breaker.get_state(),
        }

    def _log(self, level: str, event: str, msg: str, extra: Optional[Dict[str, Any]] = None):
        payload = {"ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()), "event": event, "message": msg}
        payload.update(self.extra_log_fields); payload.update(extra or {})
        line = json.dumps(payload, ensure_ascii=False)
        getattr(logger, level, logger.info)(line)

    def _record_failure(self): 
        with self._lock: self._failures += 1

    # ---- the same chat call your agent uses, plus retries/metrics ----
    def call_chat(
        self,
        messages: List[Dict[str, Any]],
        model: str,
        max_tokens: int = 512,
        temperature: float = 0.0,
        guardrail_profile: Optional[str] = None,
    ) -> Dict[str, Any]:
        if not self._breaker.allow():
            self._record_failure()
            raise RAIError("Circuit.Open", "Circuit breaker is OPEN")

        start_overall = time.perf_counter()
        last_exc: Optional[Exception] = None

        for attempt in range(self.max_retries + 1):
            try:
                t0 = time.perf_counter()
                # >>> This is exactly what your agent does <<<
                resp = self.cli.chat.create(
                    model=model,
                    messages=messages,
                    max_tokens=max_tokens,
                    temperature=temperature,
                    guardrail_profile=guardrail_profile,
                )
                dt_ms = (time.perf_counter() - t0) * 1000.0

                with self._lock:
                    self._total_calls += 1
                    self._latencies_ms.append(dt_ms)

                self._breaker.on_success()
                self._log("info","rai_success","ok",{"attempt":attempt+1,"latency_ms":round(dt_ms,2)})
                return resp

            except Exception as e:
                last_exc = e
                self._record_failure()
                self._breaker.on_failure()

                elapsed = time.perf_counter() - start_overall
                final = attempt >= self.max_retries or elapsed >= self.max_total_retry_seconds
                self._log("warning","rai_failure",str(e),{
                    "attempt":attempt+1,"retry_planned": not final, "breaker": self._breaker.get_state()
                })
                if self.on_failure:
                    try: self.on_failure({"attempt":attempt+1,"error":str(e)})
                    except Exception as cb: self._log("error","failure_callback_error",str(cb))

                if final: break
                time.sleep(self._compute_backoff(attempt))

        self._log("error","rai_ultimate_failure",f"failed after {self.max_retries+1} attempts")
        raise RAIError("Call.Failed","RAI call failed") from last_exc
