
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RAI Gateway Client — Final Hybrid Version
-----------------------------------------
✅ Uses SSRAI SDK directly (no HTTP or SSL interference)
✅ Retries + exponential backoff + jitter
✅ Circuit breaker identical to original utility
✅ Locust 2.41.2 used *only* for metrics (no monkey patch)
✅ Rotating JSONL logs:
    - rai_client_events.jsonl
    - manual_metrics.jsonl
    - locust_metrics.jsonl
"""

import os
import time
import math
import json
import random
import logging
import threading
from collections import deque
from logging.handlers import RotatingFileHandler
from typing import Any, Callable, Deque, Dict, List, Optional

# -------------------------------------------------------
# Prevent Locust/gevent monkey-patching of SSL
# -------------------------------------------------------
os.environ.setdefault("LOCUST_NO_MONKEY_PATCH", "1")

# Official RAI Gateway SDK
from ssrai import SSRAIClient

# Locust purely for metrics
from locust.env import Environment


# ------------------------- LOGGERS -------------------------
def setup_logger(name: str, file: str) -> logging.Logger:
    """Rotating JSONL logger."""
    logger = logging.getLogger(name)
    logger.setLevel(logging.INFO)
    logger.propagate = False
    if not logger.handlers:
        os.makedirs(os.path.dirname(os.path.abspath(file)), exist_ok=True)
        fh = RotatingFileHandler(file, maxBytes=10 * 1024 * 1024, backupCount=3)
        fh.setFormatter(logging.Formatter("%(message)s"))
        logger.addHandler(fh)
    return logger


# ------------------------- CIRCUIT BREAKER -------------------------
class CircuitBreaker:
    """Stops calls temporarily when repeated failures occur."""

    def __init__(self, fail_threshold: int = 10, half_open_after: float = 30.0):
        self.state = "CLOSED"  # CLOSED | OPEN | HALF_OPEN
        self.fail_count = 0
        self.opened_at = 0.0
        self.fail_threshold = fail_threshold
        self.half_open_after = half_open_after
        self._lock = threading.Lock()

    def allow(self) -> bool:
        with self._lock:
            if self.state == "OPEN" and (time.time() - self.opened_at) > self.half_open_after:
                self.state = "HALF_OPEN"  # allow one test call
            return self.state != "OPEN"

    def on_success(self):
        with self._lock:
            self.fail_count = 0
            self.state = "CLOSED"

    def on_failure(self):
        with self._lock:
            self.fail_count += 1
            if self.fail_count >= self.fail_threshold:
                self.state = "OPEN"
                self.opened_at = time.time()

    def get_state(self) -> str:
        with self._lock:
            return self.state


# ------------------------- CUSTOM ERROR -------------------------
class RAIError(Exception):
    def __init__(self, code: str, message: str):
        super().__init__(message)
        self.code = code


# ------------------------- MAIN CLIENT -------------------------
class RAIGatewayClient:
    """
    SSRAIClient wrapper with:
    - Retries + backoff
    - Circuit breaker
    - Manual + Locust metrics
    """

    def __init__(
        self,
        config_file: str,
        profile: Optional[str] = None,
        *,
        max_retries: int = 3,
        backoff_base_seconds: float = 0.5,
        backoff_max_seconds: float = 10.0,
        max_total_retry_seconds: float = 30.0,
        metrics_window_size: int = 5000,
        breaker_fail_threshold: int = 10,
        breaker_half_open_after: float = 30.0,
        extra_log_fields: Optional[Dict[str, Any]] = None,
        on_failure: Optional[Callable[[Dict[str, Any]], None]] = None,
        enable_locust_metrics: bool = True,
    ):
        # Initialize SSRAIClient
        self.cli = SSRAIClient(config_file=config_file, profile=profile)
        self.extra_log_fields = extra_log_fields or {}

        # PAT injection
        if getattr(self.cli, "auth_type", None) == "pat" and not getattr(self.cli, "pat_token", None):
            env_pat = os.getenv("SSRAI_PAT_TOKEN")
            if env_pat:
                self.cli.pat_token = env_pat

        # Config
        self.max_retries = int(max_retries)
        self.backoff_base_seconds = float(backoff_base_seconds)
        self.backoff_max_seconds = float(backoff_max_seconds)
        self.max_total_retry_seconds = float(max_total_retry_seconds)

        # Circuit breaker
        self._breaker = CircuitBreaker(breaker_fail_threshold, breaker_half_open_after)

        # Manual metrics
        self._latencies_ms: Deque[float] = deque(maxlen=int(metrics_window_size))
        self._total_calls = 0
        self._failures = 0
        self._lock = threading.Lock()

        # Logging
        self.events_logger = setup_logger("RAIClient.events", "rai_client_events.jsonl")
        self.manual_logger = setup_logger("RAIClient.manual", "manual_metrics.jsonl")
        self.locust_logger = setup_logger("RAIClient.locust", "locust_metrics.jsonl")

        # Callbacks
        self.on_failure = on_failure

        # Locust setup
        self._locust_env = Environment(user_classes=[]) if enable_locust_metrics else None

    # ------------------------- HELPERS -------------------------
    def _log(self, event: str, message: str, extra: Optional[Dict[str, Any]] = None):
        payload = {
            "ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()),
            "event": event,
            "message": message,
            **self.extra_log_fields,
        }
        if extra:
            payload.update(extra)
        self.events_logger.info(json.dumps(payload, ensure_ascii=False))

    def _compute_backoff(self, attempt: int) -> float:
        base = self.backoff_base_seconds * (2 ** attempt)
        return random.uniform(0, min(base, self.backoff_max_seconds))

    # ------------------------- METRICS -------------------------
    @staticmethod
    def _percentile(sorted_values: List[float], p: float) -> float:
        if not sorted_values:
            return 0.0
        k = (len(sorted_values) - 1) * (p / 100.0)
        f, c = math.floor(k), math.ceil(k)
        if f == c:
            return sorted_values[int(k)]
        return sorted_values[f] * (c - k) + sorted_values[c] * (k - f)

    def _record_locust(self, name: str, latency_ms: float, ok: bool, err: Optional[Exception]):
        if not self._locust_env:
            return
        try:
            stats = self._locust_env.stats
            entry = stats.get("RAI", name)
            latency = int(round(latency_ms))
            if ok:
                entry.log_request("RAI", name, latency, response_length=0)
                stats.total.log_request("RAI", name, latency, response_length=0)
            else:
                entry.num_failures += 1
                stats.total.num_failures += 1
                entry.log_error(err or Exception("Unknown failure"))

            # Snapshot to locust_metrics.jsonl
            s = stats.total
            total = s.num_requests
            fails = s.num_failures
            succ_rate = ((total - fails) / total * 100.0) if total else 0.0
            try:
                p50 = s.get_current_response_time_percentile(0.50)
                p95 = s.get_current_response_time_percentile(0.95)
            except Exception:
                p50 = p95 = 0.0
            data = {
                "ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()),
                "model": name,
                "ok": ok,
                "latency_ms": latency,
                "locust_num_requests": total,
                "locust_num_failures": fails,
                "locust_success_rate_pct": round(succ_rate, 2),
                "locust_avg_latency_ms": round(getattr(s, "avg_response_time", 0.0), 2),
                "locust_p50_latency_ms": round(p50 or 0.0, 2),
                "locust_p95_latency_ms": round(p95 or 0.0, 2),
                **self.extra_log_fields,
            }
            self.locust_logger.info(json.dumps(data, ensure_ascii=False))
        except Exception as e:
            self._log("locust_error", str(e))

    def _log_manual_metrics(self):
        with self._lock:
            lat = list(self._latencies_ms)
            total = self._total_calls
            fails = self._failures
        lat_sorted = sorted(lat)
        avg = sum(lat_sorted) / len(lat_sorted) if lat_sorted else 0.0
        p50 = self._percentile(lat_sorted, 50)
        p95 = self._percentile(lat_sorted, 95)
        succ_rate = ((total - fails) / total * 100.0) if total else 0.0
        data = {
            "ts": time.strftime("%Y-%m-%dT%H:%M:%S", time.gmtime()),
            "manual_total_calls": total,
            "manual_failures": fails,
            "manual_success_rate_pct": round(succ_rate, 2),
            "manual_avg_latency_ms": round(avg, 2),
            "manual_p50_latency_ms": round(p50, 2),
            "manual_p95_latency_ms": round(p95, 2),
            **self.extra_log_fields,
        }
        self.manual_logger.info(json.dumps(data, ensure_ascii=False))

    # ------------------------- CORE CALL -------------------------
    def call_chat(
        self,
        messages: List[Dict[str, Any]],
        model: str,
        *,
        max_tokens: int = 512,
        temperature: float = 0.0,
        guardrail_profile: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Call RAI Gateway with retries, backoff, circuit breaker, and metrics."""
        if not self._breaker.allow():
            with self._lock:
                self._failures += 1
            self._record_locust(model, 0.0, ok=False, err=RAIError("Circuit.Open", "OPEN"))
            raise RAIError("Circuit.Open", "Circuit breaker is OPEN")

        start_overall = time.perf_counter()
        last_exc: Optional[Exception] = None

        for attempt in range(self.max_retries + 1):
            t0 = time.perf_counter()
            self._log("retry_attempt_start", f"attempt={attempt+1}/{self.max_retries+1}", {"model": model})
            try:
                resp = self.cli.chat.create(
                    model=model,
                    messages=messages,
                    max_tokens=max_tokens,
                    temperature=temperature,
                    guardrail_profile=guardrail_profile,
                )
                latency_ms = (time.perf_counter() - t0) * 1000.0
                with self._lock:
                    self._total_calls += 1
                    self._latencies_ms.append(latency_ms)
                self._breaker.on_success()
                self._record_locust(model, latency_ms, ok=True, err=None)
                self._log("retry_attempt_end", "success", {"attempt": attempt + 1, "latency_ms": round(latency_ms, 2)})
                self._log_manual_metrics()
                return resp

            except Exception as e:
                last_exc = e
                elapsed = time.perf_counter() - start_overall
                final = (attempt >= self.max_retries) or (elapsed >= self.max_total_retry_seconds)
                latency_ms = (time.perf_counter() - t0) * 1000.0
                with self._lock:
                    self._total_calls += 1
                    self._failures += 1
                    self._latencies_ms.append(latency_ms)
                self._breaker.on_failure()
                self._record_locust(model, latency_ms, ok=False, err=e)
                self._log(
                    "retry_attempt_end",
                    "failure",
                    {
                        "attempt": attempt + 1,
                        "error": str(e),
                        "retry_planned": not final,
                        "breaker": self._breaker.get_state(),
                        "latency_ms": round(latency_ms, 2),
                        "model": model,
                    },
                )
                if self.on_failure:
                    try:
                        self.on_failure({"attempt": attempt + 1, "error": str(e)})
                    except Exception as cb:
                        self._log("failure_callback_error", str(cb))
                if final:
                    self._log_manual_metrics()
                    break
                time.sleep(self._compute_backoff(attempt))

        self._log("rai_ultimate_failure", f"failed after {self.max_retries+1} attempts", {"model": model})
        raise RAIError("Call.Failed", "RAI call failed") from last_exc

    # ------------------------- FACTORY -------------------------
    @classmethod
    def from_cfg(cls, cfg_path: str, *, profile: Optional[str] = None, **kwargs):
        return cls(config_file=cfg_path, profile=profile, **kwargs)
